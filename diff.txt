1168a1169,1251
> im the input 
> For most simple cases, you should be able to leverage the Tina Client's generated queries to do your data fetching:
> 
> ```ts
> const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
> ```
> 
> In more advanced cases, you may want more control on the underlying GraphQL query. In these cases you have two options:
> 
> * Extending the auto-generated `client.queries` by writing a custom query.
> * Use `client.request`, and write an inline query.
> 
> 
> im the output  For most simple cases, you should be able to leverage the Tina Client's generated queries to do your data fetching:  ts const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })   In more advanced cases, you may want more control on the underlying GraphQL query. In these cases you have two options:   Extending the auto-generated client.queries by writing a custom query.  Use client.request, and write an inline query.  
> im the input Extending the auto-generated `client.queries`
> 
> The client can be extended to perform more advanced queries (including querying multiple root collections at once), by adding queries to the `tina/queries` directory. All files that end in `gql` or `graphql` in this directory will be added to the client.
> 
> Tina generates custom [GraphQL fragments](https://graphql.org/learn/queries/#fragments) to be used in custom queries so that the queries will not have to be updated when the schema is updated.
> 
> > Note: These fragments can be seen in `tina/__generated__/frags.gql`
> 
> Example of `tina/queries/postWithNav.gql`:
> 
> ```ts
> query postWithNav($relativePath: String!) {
>   nav(relativePath: "nav.json") {
>     ...NavParts
>   }
>   post(relativePath: $relativePath) {
>     ...PostParts
>   }
> }
> ```
> 
> To get autocomplete in your GraphQL files add a [`graphql.config.js`](https://github.com/tinacms/tina-cloud-starter/blob/main/graphql.config.js) that points to `tina/__generated__/schema.gql` and `tina/__generated__/frags.gql`.
> 
> > Note: fragments are named by using the collection name (capitalized) followed by "Parts"
> 
> We are using a `PostParts` & `NavParts` Fragment here. For each collection, this fragment is generated and updated when the schema is updated. You can view any available Fragments for your schema in `/tina/__generated__/frags.gql`.
> 
> Once the query is added, the client will have its types updated so that it can be used to request the new query.
> 
> ```js
> import { client } from '../[pathToTina]/tina/__generated__/client'
> 
> // Use the client to perform data fetching
> // Here, it fetches a single "post" item
> const myPost = await client.queries.postWithNav({
>   relativePath: 'HelloWorld.md',
> })
> 
> console.log(myPost.title)
> console.log(myPost.nav.items)
> ```
> 
> 
> im the output Extending the auto-generated client.queries  The client can be extended to perform more advanced queries (including querying multiple root collections at once), by adding queries to the tina/queries directory. All files that end in gql or graphql in this directory will be added to the client.  Tina generates custom GraphQL fragments to be used in custom queries so that the queries will not have to be updated when the schema is updated.  Note: These fragments can be seen in tina/generated/frags.gql  Example of tina/queries/postWithNav.gql:  ts query postWithNav($relativePath: String!) {   nav(relativePath: "nav.json") {     ...NavParts   }   post(relativePath: $relativePath) {     ...PostParts   } }   To get autocomplete in your GraphQL files add a graphql.config.js that points to tina/generated/schema.gql and tina/generated/frags.gql.  Note: fragments are named by using the collection name (capitalized) followed by "Parts"  We are using a PostParts & NavParts Fragment here. For each collection, this fragment is generated and updated when the schema is updated. You can view any available Fragments for your schema in /tina/generated/frags.gql.  Once the query is added, the client will have its types updated so that it can be used to request the new query.  js import { client } from '../[pathToTina]/tina/generated/client'  // Use the client to perform data fetching // Here, it fetches a single "post" item const myPost = await client.queries.postWithNav({   relativePath: 'HelloWorld.md', })  console.log(myPost.title) console.log(myPost.nav.items)   
> im the input Writing inline queries
> 
> If you want to avoid using the types on the client altogether, you can also just write an inline query using the `client.request` function.
> 
> ```js
> import { client } from '../[pathToTina]/tina/__generated__/client'
> 
> // Use the client to perform data fetching
> // Here, it fetches a single "post" item
> const myPost = await client.request({
>   query: `query getPost($relativePath: String!) {
>       post(relativePath: $relativePath) {
>         title
>         body
>       }
>     `,
>   variables: { relativePath: 'hello-world.md' },
> })
> 
> console.log(myPost.title)
> ```
> 
> For more information on writing custom queries, check out the [querying reference docs](/docs/graphql/queries/).
> 
> im the output Writing inline queries  If you want to avoid using the types on the client altogether, you can also just write an inline query using the client.request function.  js import { client } from '../[pathToTina]/tina/generated/client'  // Use the client to perform data fetching // Here, it fetches a single "post" item const myPost = await client.request({   query: query getPost($relativePath: String!) {       post(relativePath: $relativePath) {         title         body       }     ,   variables: { relativePath: 'hello-world.md' }, })  console.log(myPost.title)   For more information on writing custom queries, check out the querying reference docs. 
1169a1253,1365
> 
> im the output  
> im the input Introduction
> As mentioned in [Introduction to Data fetching](/docs/features/data-fetching/), Tina provides a client for querying content.
> 
> > Note, for advanced use-cases, you can also manually query the underlying [GraphQL API](/docs/data-fetching/custom-queries/#writing-inline-queries).
> 
> 
> im the output Introduction As mentioned in Introduction to Data fetching, Tina provides a client for querying content.  Note, for advanced use-cases, you can also manually query the underlying GraphQL API.  
> im the input Querying a single document
> 
> ```js
> import { client } from '../[pathToTina]/tina/__generated__/client'
> 
> const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
> 
> console.log(myPost.title)
> ```
> 
> In the above example `post` is the name of the collection being queried. This can be replaced with one of your schema's defined collection names.
> 
> 
> im the output Querying a single document  js import { client } from '../[pathToTina]/tina/generated/client'  const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })  console.log(myPost.title)   In the above example post is the name of the collection being queried. This can be replaced with one of your schema's defined collection names.  
> im the input Querying a list of documents
> 
> ```js
> const postsResponse = await client.queries.postConnection()
> const posts = postsResponse.data.postConnection.edges.map((post) => {
>   return { slug: post.node._sys.filename }
> })
> // This would return an array like: [ { slug: 'HelloWorld.md'}, /*...*/ ]
> ```
> 
> `<collection-name>Connection` can be used to query a list of documents (in the above example, our collection name is `post`).
> 
> #
> im the output Querying a list of documents  js const postsResponse = await client.queries.postConnection() const posts = postsResponse.data.postConnection.edges.map((post) ={   return { slug: post.node.sys.filename } }) // This would return an array like: [ { slug: 'HelloWorld.md'}, /.../ ]   <collection-nameConnection can be used to query a list of documents (in the above example, our collection name is post).  #
> im the input Filtering
> 
> Filters can be added as an option to your `<collection-name>Collection` query.
> 
> ```js
> const postsResponse = await client.queries.postConnection({
>   filter: { title: { startsWith: 'Vote' } },
> })
> 
> // ...
> ```
> 
> The following operator types are available for querying
> 
> | Key        | Behavior                 | Type(s)                          |
> | :--------- | ------------------------ | -------------------------------- |
> | eq         | Equals                   | string, number, boolean          |
> | in         | One of                   | string\[], number\[], boolean\[] |
> | gt         | Greater than             | string, number                   |
> | gte        | Greater than or equal to | string, number                   |
> | lt         | Less than                | string, number                   |
> | lte        | Less than or equal to    | string, number                   |
> | startsWith | Starts with              | string                           |
> | after      | After                    | datetime                         |
> | before     | Before                   | datetime                         |
> 
> > Only `gt`, `gte`, `lt`, `lte`, `after`, `before` may be used in ternary conditions.
> 
> #
> im the output Filtering  Filters can be added as an option to your <collection-nameCollection query.  js const postsResponse = await client.queries.postConnection({   filter: { title: { startsWith: 'Vote' } }, })  // ...   The following operator types are available for querying  | Key        | Behavior                 | Type(s)                          | | : |  |  | | eq         | Equals                   | string, number, boolean          | | in         | One of                   | string\[], number\[], boolean\[] | | gt         | Greater than             | string, number                   | | gte        | Greater than or equal to | string, number                   | | lt         | Less than                | string, number                   | | lte        | Less than or equal to    | string, number                   | | startsWith | Starts with              | string                           | | after      | After                    | datetime                         | | before     | Before                   | datetime                         |  Only gt, gte, lt, lte, after, before may be used in ternary conditions.  #
> im the input Sorting
> 
> Sorting can be added as an option to your `<collection-name>Collection` query.
> 
> ```js
> const postsResponse = await client.queries.postConnection({
>   sort: 'date',
> })
> 
> // ...
> ```
> 
> ##
> im the output Sorting  Sorting can be added as an option to your <collection-nameCollection query.  js const postsResponse = await client.queries.postConnection({   sort: 'date', })  // ...   ##
> im the input Sorting on multiple fields
> 
> Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:
> 
> ```js
> const postsResponse = await client.queries.postConnection({
>   sort: 'category-date',
> })
> 
> // ...
> ```
> 
> #
> im the output Sorting on multiple fields  Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:  js const postsResponse = await client.queries.postConnection({   sort: 'category-date', })  // ...   #
> im the input Pagination
> 
> Tina supports cursor-based pagination:
> 
> ```js
> const postsResponse = await client.queries.postConnection({
>   first: 10,
>   after:
>     'cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==',
> })
> 
> // ...
> ```
> 
> One caveat to using the built-in queries on the client is that **you can only query one root collection at a time**. If you have a page that has multiple forms on it, you may need to use [custom queries](/docs/data-fetching/custom-queries/).
> 
> im the output Pagination  Tina supports cursor-based pagination:  js const postsResponse = await client.queries.postConnection({   first: 10,   after:     'cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==', })  // ...   One caveat to using the built-in queries on the client is that you can only query one root collection at a time. If you have a page that has multiple forms on it, you may need to use custom queries. 
> im the input 
1492a1689,1835
> im the input 
> Adding a "Draft Field" is one approach to handling "drafts" in TinaCMS
> 
> 
> im the output  Adding a "Draft Field" is one approach to handling "drafts" in TinaCMS  
> im the input What is a "Draft Field"?
> 
> "Draft Fields" are just simply fields that can be used to indicate whether a document is a draft or not. There is nothing special about draft fields, are they are not treated any differently then any other boolean field.
> 
> #
> im the output What is a "Draft Field"?  "Draft Fields" are just simply fields that can be used to indicate whether a document is a draft or not. There is nothing special about draft fields, are they are not treated any differently then any other boolean field.  #
> im the input Setting up a draft field
> 
> The "draft" field can be added to the top level fields of a collection.
> 
> ```ts
> const schema = defineSchema({
>   collections: [
>     {
>       name: 'post',
>       label: 'Post',
>       path: 'content/posts',
>       fields: [
>         {
>           name: 'draft',
>           label: 'Draft',
>           type: 'boolean',
>           required: true,
>           description: 'If this is checked the post will not be published',
>         },
>         // ... other fields
>       ],
>     },
>   ],
> })
> ```
> 
> > Note: It's usually a good practice to make draft fields required. This may require adding the draft field to your existing documents
> 
> #
> im the output Setting up a draft field  The "draft" field can be added to the top level fields of a collection.  ts const schema = defineSchema({   collections: [     {       name: 'post',       label: 'Post',       path: 'content/posts',       fields: [         {           name: 'draft',           label: 'Draft',           type: 'boolean',           required: true,           description: 'If this is checked the post will not be published',         },         // ... other fields       ],     },   ], })   Note: It's usually a good practice to make draft fields required. This may require adding the draft field to your existing documents  #
> im the input Excluding drafts from your production queries
> 
> You can add a filter to filter out draft documents from your queries:
> 
> ```ts
> // getting production posts
> const req = await client.queries.postConnection({
>   filter: { draft: { eq: false } },
> })
> 
> // getting all posts
> const req = await client.queries.postConnection()
> ```
> 
> Read more about querying data [here](/docs/data-fetching/overview).
> 
> > If you're using a Draft field with a static site generator like Hugo, any documents with "draft: true" will be omitted from your production site out-of-the-box.
> 
> 
> im the output Excluding drafts from your production queries  You can add a filter to filter out draft documents from your queries:  ts // getting production posts const req = await client.queries.postConnection({   filter: { draft: { eq: false } }, })  // getting all posts const req = await client.queries.postConnection()   Read more about querying data here.  If you're using a Draft field with a static site generator like Hugo, any documents with "draft: true" will be omitted from your production site out-of-the-box.  
> im the input Caveats:
> 
> - The above solution won't work as-is with [visual editing](/docs/contextual-editing/overview). To setup visual editing with drafts, you will need to implement [NextJS Preview-Mode](/guides/tinacms/contextual-drafts/guide/).
> 
> im the output Caveats:  - The above solution won't work as-is with visual editing. 
> im the input 
> <Youtube embedSrc="https://www.youtube.com/embed/gYukiULGqGc" />
> 
> > Note: The editorial workflow feature is only available for projects on the business and enterprise plans.
> 
> If your content editors need to work on multiple branches, you can utilize the Editorial Workflow feature. Instead of saving your content directly to a protected branch (e.g., `main`), a new branch is created. A draft pull request is generated, and all subsequent edits are made on this new branch. When your content is ready to be published, it can be merged back into the protected branch (e.g., `main`) via GitHub.
> 
> 
> im the output  <Youtube embedSrc="https://www.youtube.com/embed/gYukiULGqGc" / Note: The editorial workflow feature is only available for projects on the business and enterprise plans.  If your content editors need to work on multiple branches, you can utilize the Editorial Workflow feature. Instead of saving your content directly to a protected branch (e.g., main), a new branch is created. A draft pull request is generated, and all subsequent edits are made on this new branch. When your content is ready to be published, it can be merged back into the protected branch (e.g., main) via GitHub.  
> im the input Setting Up
> 
> The Editorial Workflow can be enabled in TinaCloud.
> 
> ![Editorial Workflow Setup](https://res.cloudinary.com/forestry-demo/image/upload/v1689016108/blog-media/editorial-workflow/enable-editorial-workflow.png)
> 
> To set up the Editorial Workflow, follow these steps:
> 
> 1. Go to the "Configuration" tab of your project in the dashboard.
> 2. Toggle the "Enable" option.
> 3. Enter the names of the branches you want to protect.
> 4. After setting up the protected branches, refresh your page to ensure the changes take effect.
> 
> 
> im the output Setting Up  The Editorial Workflow can be enabled in TinaCloud.    To set up the Editorial Workflow, follow these steps:  1. Go to the "Configuration" tab of your project in the dashboard. 2. Toggle the "Enable" option. 3. Enter the names of the branches you want to protect. 4. After setting up the protected branches, refresh your page to ensure the changes take effect.  
> im the input Accessing CMS and Saving to Protected Branches
> 
> After completing the setup, you can access the CMS, and a new branch switcher button will appear at the top. When you are on a protected branch and click "Save," a modal will prompt you to enter the name of the new branch you wish to save to.
> 
> ![Editorial Workflow Save](https://res.cloudinary.com/forestry-demo/image/upload/v1689033651/blog-media/editorial-workflow/create-branch_bgpgwn.png)
> 
> Once you enter the new branch name, the following actions will occur:
> 
> - The new branch will be created.
> - The content of the new branch will be indexed (this process may take a few minutes).
> - The changes will be saved to the new branch.
> - A draft pull request will be created.
> 
> 
> im the output Accessing CMS and Saving to Protected Branches  After completing the setup, you can access the CMS, and a new branch switcher button will appear at the top. When you are on a protected branch and click "Save," a modal will prompt you to enter the name of the new branch you wish to save to.    Once you enter the new branch name, the following actions will occur:  - The new branch will be created. - The content of the new branch will be indexed (this process may take a few minutes). - The changes will be saved to the new branch. - A draft pull request will be created.  
> im the input Publishing Content
> 
> When you are ready to publish your content, merge the draft pull request into the protected branch (e.g., main) through GitHub. After the pull request is successfully merged, the updated content will be available on the protected branch.
> 
> 
> im the output Publishing Content  When you are ready to publish your content, merge the draft pull request into the protected branch (e.g., main) through GitHub. After the pull request is successfully merged, the updated content will be available on the protected branch.  
> im the input GitHub Pull Request links
> 
> In the branch list modal, you can click on the dropdown and click "View Pull Request" to view the pull request on GitHub. This will open a new tab in your browser. This link will only aprear of the pull request has been created with TinaCMS and not if it was created manually.
> 
> ![PR Links](https://res.cloudinary.com/forestry-demo/image/upload/v1689082820/blog-media/editorial-workflow/preview-link.png)
> 
> 
> im the output GitHub Pull Request links  In the branch list modal, you can click on the dropdown and click "View Pull Request" to view the pull request on GitHub. This will open a new tab in your browser. This link will only aprear of the pull request has been created with TinaCMS and not if it was created manually.    
> im the input Preview links
> 
> You can setup preview links for your pull requests.
> 
> ![Editorial Workflow Save](https://res.cloudinary.com/forestry-demo/image/upload/v1689035096/blog-media/editorial-workflow/share-btn_xvmxii.png)
> 
> This will allow you to preview your content changes before merging them into the protected branch. To setup preview links, In your config file add a `previewUrl` function to the `ui` object. This function will receive the branch name as an argument and should return the preview url for that branch. For example:
> 
> ```js
> // tina/config.{ts,tsx,js}
> 
> export default defineConfig({
>   // ...
>   ui: {
>     // Eg. If you're deplying to Vercel, and your repo name is 'my-app', Vercel's preview URL would be based on the branch:
>     previewUrl: (context) => {
>       const repoName = 'my-app'
>       // `https://<project-name>-git-<branch-name>.vercel.app`
>       return { url: `https://my-app-git-${context.branch}` }
>     },
>   },
>   //...
> })
> ```
> 
> Now you will be able to click on the "View Preview" button in the branch list modal to preview your changes.
> 
> im the output Preview links  You can setup preview links for your pull requests.    This will allow you to preview your content changes before merging them into the protected branch. To setup preview links, In your config file add a previewUrl function to the ui object. This function will receive the branch name as an argument and should return the preview url for that branch. For example:  js // tina/config.{ts,tsx,js}  export default defineConfig({   // ...   ui: {     // Eg. If you're deplying to Vercel, and your repo name is 'my-app', Vercel's preview URL would be based on the branch:     previewUrl: (context) ={       const repoName = 'my-app'       // https://<project-name-git-<branch-name.vercel.app       return { url: https://my-app-git-${context.branch} }     },   },   //... })   Now you will be able to click on the "View Preview" button in the branch list modal to preview your changes. 
1493a1837,2071
> TinaCMS supports a few implementations of "drafts".
> 
> 
> im the output  TinaCMS supports a few implementations of "drafts".  
> im the input Document-based "draft" state
> 
> Developers can setup a "draft" field on a document, which can be toggled to conditionally include pages based on their draft state.
> 
> [Read more about implementing a "draft field" here](/docs/drafts/drafts-fields)
> 
> 
> im the output Document-based "draft" state  Developers can setup a "draft" field on a document, which can be toggled to conditionally include pages based on their draft state.  Read more about implementing a "draft field" here  
> im the input Working in branches
> 
> Some editorial teams like to work in branches, for more control over what gets merged into production.
> 
> In these cases, you may want to have your editors work from your hosting provider's preview deployments, instead of `<your-production-site>/admin`.
> 
> See our [TinaCloud Docs](/docs/tina-cloud/dashboard/projects/#glob-patterns) for help setting this up.
> 
> im the output Working in branches  Some editorial teams like to work in branches, for more control over what gets merged into production.  In these cases, you may want to have your editors work from your hosting provider's preview deployments, instead of <your-production-site/admin.  See our TinaCloud Docs for help setting this up. 
> im the input 
> This error happens when a collection uses templates and there is no template key found in the document. It is common for this to happen when migrating from fields to templates or during forestry migration.
> 
> 
> im the output  This error happens when a collection uses templates and there is no template key found in the document. It is common for this to happen when migrating from fields to templates or during forestry migration.  
> im the input How to fix
> 
> This error can be fixed by adding a root level field of \_template to every document with this error.  There is not currently any way to automatically migrate the content and it must be done manually or with custom scripts.
> 
> Ex:
> If you had a markdown file you would add:
> 
> ```markdown
> ---
> _template: templateName
> ---
> ```
> 
> Where `templateName` is the name of the template in your collection
> 
> If it was a JSON file it would look like this.
> 
> ```json
> {
>   "_template": "templateName",
> }
> ```
> 
> etc.
> 
> [Check out this video](https://www.loom.com/share/077e2a626f4246b1b680526433ef1e33?sid=612ce485-d386-479b-a9c2-1de55ec6f24c "Ambiguous Template Video") for a deeper explanation.
> 
> im the output How to fix  This error can be fixed by adding a root level field of \template to every document with this error.  There is not currently any way to automatically migrate the content and it must be done manually or with custom scripts.  Ex: If you had a markdown file you would add:  markdown  template: templateName    Where templateName is the name of the template in your collection  If it was a JSON file it would look like this.  json {   "template": "templateName", }   etc.  Check out this video for a deeper explanation. 
> im the input 
> The `tina/config.{ts,js,tsx}` file is built with [esbuild](https://esbuild.github.io/) and executed in a node.js runtime. This allows you to import from outside your `.tina` folder and esbuild will handle this for us. This also can run into some edge cases where some things are being run on the server that should not be.
> 
> 
> im the output  The tina/config.{ts,js,tsx} file is built with esbuild and executed in a node.js runtime. This allows you to import from outside your .tina folder and esbuild will handle this for us. This also can run into some edge cases where some things are being run on the server that should not be.  
> im the input ERROR: your schema was not successfully built
> 
> This means that there was a syntax or semantic error somewhere in your code. This could be inside the .tina folder or in any file that was imported from your schema file.
> 
> 
> im the output ERROR: your schema was not successfully built  This means that there was a syntax or semantic error somewhere in your code. This could be inside the .tina folder or in any file that was imported from your schema file.  
> im the input ERROR: your config.{ts,js} was not successfully executed
> 
> This error means that the schema was compiled correctly (correct syntax) but when the code was run it produced an error.
> 
> Some common issues are
> 
> - Importing code that requires a custom compile logic (webpack loader, esbuild loader, babel plugin, etc)
> - Importing and running code that needs to be run on the frontend (uses `window`, DOM APIs, etc)
> 
> If you run into one of the above issues you can try only importing the code that you need.
> 
> For example you might have
> 
> ```ts
> import { TinaHeroTemplate } from '../components/'
> ```
> 
> which could be switched to
> 
> ```ts
> import { TinaHeroTemplate } from '../components/blocks/hero'
> ```
> 
> Using this more specific path means it is less likely that you will run into errors
> 
> Still confused? Don't worry we are here to help please [reach out to us on discord](https://discord.gg/njvZZYHj2Q) or submit a [github issue](https://github.com/tinacms/tinacms/issues/new/choose) and we will get back to you as soon as possible.
> 
> im the output ERROR: your config.{ts,js} was not successfully executed  This error means that the schema was compiled correctly (correct syntax) but when the code was run it produced an error.  Some common issues are  - Importing code that requires a custom compile logic (webpack loader, esbuild loader, babel plugin, etc) - Importing and running code that needs to be run on the frontend (uses window, DOM APIs, etc)  If you run into one of the above issues you can try only importing the code that you need.  For example you might have  ts import { TinaHeroTemplate } from '../components/'   which could be switched to  ts import { TinaHeroTemplate } from '../components/blocks/hero'   Using this more specific path means it is less likely that you will run into errors  Still confused? Don't worry we are here to help please reach out to us on discord and we will get back to you as soon as possible. 
> im the input 
> This error occurs when a file is in multiple collections. This is usually caused by overlapping paths in in your collections or an error in a [match property](/docs/reference/collections#matchinclude).
> 
> The common fix for this is updating or adding the [match property](/docs/reference/collections#matchinclude) to exclude or include certain files.
> 
> 
> im the output  This error occurs when a file is in multiple collections. This is usually caused by overlapping paths in in your collections or an error in a match property.  The common fix for this is updating or adding the match property to exclude or include certain files.  
> im the input Example with exclude
> 
> ```ts
> // tina/schema.ts
> export default defineConfig({
>   collections: [
>     {
>       label: 'Blog Posts',
>       name: 'posts',
>       path: 'content/posts',
>       // ..
>     },
>     {
>       label: 'Featured Posts',
>       name: 'featuredPosts',
>       path: 'content/posts/featured',
>       // ...
>     },
>     //..
>   ],
>   // ...
> })
> ```
> 
> The example configuration above would cause an overlap because the Blog Post collection will contain all of the files in the Featured Posts collection. This can be fixed by updating the [`match.exclude` property](/docs/reference/collections#matchexclude) on the Blog Posts collection to exclude all of the files in the Features Posts collection.
> 
> ```ts
> // tina/schema.ts
> export default defineConfig({
>   collections: [
>     {
>       label: 'Blog Posts',
>       name: 'posts',
>       path: 'content/posts',
>       match: {
>         exclude: 'featured/**/**',
>       },
>       // ..
>     },
>     {
>       label: 'Featured Posts',
>       name: 'featuredPosts',
>       path: 'content/posts/featured',
>       // ...
>     },
>     //..
>   ],
>   // ...
> })
> ```
> 
> 
> im the output Example with exclude  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       // ..     },     {       label: 'Featured Posts',       name: 'featuredPosts',       path: 'content/posts/featured',       // ...     },     //..   ],   // ... })   The example configuration above would cause an overlap because the Blog Post collection will contain all of the files in the Featured Posts collection. This can be fixed by updating the match.exclude property on the Blog Posts collection to exclude all of the files in the Features Posts collection.  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       match: {         exclude: 'featured//',       },       // ..     },     {       label: 'Featured Posts',       name: 'featuredPosts',       path: 'content/posts/featured',       // ...     },     //..   ],   // ... })   
> im the input Example with include
> 
> An example of include could be if you only wanted to include files with a certain name. For example if you wanted to include all of the files in the `content/posts` directory that had the name `index`.
> 
> ```ts
> // tina/schema.ts
> export default defineConfig({
>   collections: [
>     {
>       label: 'Blog Posts',
>       name: 'posts',
>       path: 'content/posts',
>       match: {
>         include: '**/**/index',
>       },
>       // ..
>     },
>     //..
>   ],
>   // ...
> })
> ```
> 
> im the output Example with include  An example of include could be if you only wanted to include files with a certain name. For example if you wanted to include all of the files in the content/posts directory that had the name index.  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       match: {         include: '//index',       },       // ..     },     //..   ],   // ... })  
> im the input 
> We have expanded the graphql API capabilities to to have a [`list` property](/docs/schema/#the-list-property) option for every field. This means that the graphql response will return a array for of [`type`](/docs/schema/#the-type-property) for this field. This is support on our backend but we still have not implanted the front end user interface for these fields yet. [Here is the relevant issue for tracking](https://github.com/tinacms/tinacms/issues/2081). There are currently two workarounds for this issue.
> 
> 
> im the output  We have expanded the graphql API capabilities to to have a list property. There are currently two workarounds for this issue.  
> im the input 1. Wrap in object field
> 
> Wrap in an [`object` field](/docs/schema/#the-object-property). If your field looked like this
> 
> ```js
> {
>     type: "image",
>     name: "images",
>     label: "Images",
>     list: true,
> }
> ```
> 
> This can be used instead
> 
> ```js
> {
>     type: "object",
>     name: "images",
>     label: "Images",
>     list: true,
>     fields: [
>         {
>             type: "image",
>             name: "image",
>             label: "A single image",
>         }
>     ]
> }
> ```
> 
> Now you will be able to and delete new images in a list.
> 
> 
> im the output 1. Wrap in object field  Wrap in an object field. If your field looked like this  js {     type: "image",     name: "images",     label: "Images",     list: true, }   This can be used instead  js {     type: "object",     name: "images",     label: "Images",     list: true,     fields: [         {             type: "image",             name: "image",             label: "A single image",         }     ] }   Now you will be able to and delete new images in a list.  
> im the input 2. Create your own custom UI
> 
> You can create your own custom user interface by adding a [custom field](/docs/extending-tina/custom-field-components). You will have to make your own component that follows that type in the schema. After that is done your field could look like this.
> 
> ```js
> {
>     type: "image",
>     name: "images",
>     label: "Images",
>     list: true,
>     ui: {
>         component: "MyCustomImageListingField",
>     }
> }
> ```
> 
> im the output 2. Create your own custom UI  You can create your own custom user interface by adding a custom field. You will have to make your own component that follows that type in the schema. After that is done your field could look like this.  js {     type: "image",     name: "images",     label: "Images",     list: true,     ui: {         component: "MyCustomImageListingField",     } }  
> im the input 
2188d2765
< Adding a "Draft Field" is one approach to handling "drafts" in TinaCMS
2189a2767,2768
> im the output  
> im the input Introduction
2191,2192c2770
< im the output  Adding a "Draft Field" is one approach to handling "drafts" in TinaCMS  
< im the input What is a "Draft Field"?
---
> With Tina, your content is stored in Git along with your codebase. Tina provides a Content API in front of your repo-based content, so that you can interact with your files as if they're in a database.
2194c2772
< "Draft Fields" are just simply fields that can be used to indicate whether a document is a draft or not. There is nothing special about draft fields, are they are not treated any differently then any other boolean field.
---
> You can:
2196,2198c2774,2776
< #
< im the output What is a "Draft Field"?  "Draft Fields" are just simply fields that can be used to indicate whether a document is a draft or not. There is nothing special about draft fields, are they are not treated any differently then any other boolean field.  #
< im the input Setting up a draft field
---
> - Query content for a given collection
> - Apply filters, sorting, pagination, etc
> - Query your content based on relational fields.
2200c2778
< The "draft" field can be added to the top level fields of a collection.
---
> To interface with the API, you can use Tina's type-safe client for data-fetching, or manually write custom GraphQL queries and hit the API yourself.
2202,2222d2779
< ```ts
< const schema = defineSchema({
<   collections: [
<     {
<       name: 'post',
<       label: 'Post',
<       path: 'content/posts',
<       fields: [
<         {
<           name: 'draft',
<           label: 'Draft',
<           type: 'boolean',
<           required: true,
<           description: 'If this is checked the post will not be published',
<         },
<         // ... other fields
<       ],
<     },
<   ],
< })
< ```
2224c2781,2782
< > Note: It's usually a good practice to make draft fields required. This may require adding the draft field to your existing documents
---
> im the output Introduction  With Tina, your content is stored in Git along with your codebase. Tina provides a Content API in front of your repo-based content, so that you can interact with your files as if they're in a database.  You can:  - Query content for a given collection - Apply filters, sorting, pagination, etc - Query your content based on relational fields.  To interface with the API, you can use Tina's type-safe client for data-fetching, or manually write custom GraphQL queries and hit the API yourself.  
> im the input Making requests with the Tina Client
2226,2228c2784
< #
< im the output Setting up a draft field  The "draft" field can be added to the top level fields of a collection.  ts const schema = defineSchema({   collections: [     {       name: 'post',       label: 'Post',       path: 'content/posts',       fields: [         {           name: 'draft',           label: 'Draft',           type: 'boolean',           required: true,           description: 'If this is checked the post will not be published',         },         // ... other fields       ],     },   ], })   Note: It's usually a good practice to make draft fields required. This may require adding the draft field to your existing documents  #
< im the input Excluding drafts from your production queries
---
> The Tina client is the easiest way to fetch your site's content. The client can be configured the `tina/config.<js|ts>` in the `defineConfig` function.
2230c2786
< You can add a filter to filter out draft documents from your queries:
---
> > Note: token, clientId and branch are **not** used in [local-mode](/docs/tina-cloud/#local-mode). To setup these values for production see [this doc](/docs/tina-cloud/overview)
2232,2235c2788,2794
< ```ts
< // getting production posts
< const req = await client.queries.postConnection({
<   filter: { draft: { eq: false } },
---
> ```js
> // tina/config.{js,ts,tsx}
> export default defineConfig({
>   schema,
>   token: '***',
>   clientId: '***',
>   branch: 'main',
2237,2239d2795
< 
< // getting all posts
< const req = await client.queries.postConnection()
2242c2798
< Read more about querying data [here](/docs/data-fetching/overview).
---
> When working locally, the client is built with the local url ([http://localhost:4001/graphql](http://localhost:4001/graphql)). When in [production mode](/docs/tina-cloud/#prod-mode), `clientId`, `branch` and `token` are used to query TinaCloud.
2244c2800
< > If you're using a Draft field with a static site generator like Hugo, any documents with "draft: true" will be omitted from your production site out-of-the-box.
---
> Tina client provides a type-safe query builder, that is auto-generated based on your site's schema:
2245a2802,2803
> ```js
> import { client } from '../[pathToTina]/tina/__generated__/client'
2247,2248c2805
< im the output Excluding drafts from your production queries  You can add a filter to filter out draft documents from your queries:  ts // getting production posts const req = await client.queries.postConnection({   filter: { draft: { eq: false } }, })  // getting all posts const req = await client.queries.postConnection()   Read more about querying data here.  If you're using a Draft field with a static site generator like Hugo, any documents with "draft: true" will be omitted from your production site out-of-the-box.  
< im the input Caveats:
---
> const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
2250c2807,2808
< - The above solution won't work as-is with [visual editing](/docs/contextual-editing/overview). To setup visual editing with drafts, you will need to implement [NextJS Preview-Mode](/guides/tinacms/contextual-drafts/guide/).
---
> console.log(myPost.data.title)
> ```
2252,2254c2810
< im the output Caveats:  - The above solution won't work as-is with visual editing. 
< im the input 
< <Youtube embedSrc="https://www.youtube.com/embed/gYukiULGqGc" />
---
> The above `client.queries.post` query is not built-in to Tina's API. This is an example of a query based on _your_ defined schema, (where you have a "post" collection defined).
2256c2812
< > Note: The editorial workflow feature is only available for projects on the business and enterprise plans.
---
> On a page that displays a list of posts, you can fetch the posts like so:
2258c2814,2820
< If your content editors need to work on multiple branches, you can utilize the Editorial Workflow feature. Instead of saving your content directly to a protected branch (e.g., `main`), a new branch is created. A draft pull request is generated, and all subsequent edits are made on this new branch. When your content is ready to be published, it can be merged back into the protected branch (e.g., `main`) via GitHub.
---
> ```js
> const postsResponse = await client.queries.postConnection()
> const posts = postsResponse.data.postConnection.edges.map((post) => {
>   return { slug: post.node._sys.filename }
> })
> // This would return an array like: [ { slug: 'HelloWorld.md'}, /*...*/ ]
> ```
2259a2822
> > For more information on manually writing queries for your specific schema, check out our ["Writing Custom Queries"](/docs/data-fetching/custom-queries/#writing-inline-queries) docs.
2261,2262d2823
< im the output  <Youtube embedSrc="https://www.youtube.com/embed/gYukiULGqGc" / Note: The editorial workflow feature is only available for projects on the business and enterprise plans.  If your content editors need to work on multiple branches, you can utilize the Editorial Workflow feature. Instead of saving your content directly to a protected branch (e.g., main), a new branch is created. A draft pull request is generated, and all subsequent edits are made on this new branch. When your content is ready to be published, it can be merged back into the protected branch (e.g., main) via GitHub.  
< im the input Setting Up
2264c2825,2826
< The Editorial Workflow can be enabled in TinaCloud.
---
> im the output Making requests with the Tina Client  The Tina client is the easiest way to fetch your site's content. The client can be configured the tina/config.<js|tsin the defineConfig function.  Note: token, clientId and branch are not used in local-mode  js // tina/config.{js,ts,tsx} export default defineConfig({   schema,   token: '',   clientId: '',   branch: 'main', })   When working locally, the client is built with the local url (http://localhost:4001/graphql, clientId, branch and token are used to query TinaCloud.  Tina client provides a type-safe query builder, that is auto-generated based on your site's schema:  js import { client } from '../[pathToTina]/tina/generated/client'  const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })  console.log(myPost.data.title)   The above client.queries.post query is not built-in to Tina's API. This is an example of a query based on your defined schema, (where you have a "post" collection defined).  On a page that displays a list of posts, you can fetch the posts like so:  js const postsResponse = await client.queries.postConnection() const posts = postsResponse.data.postConnection.edges.map((post) ={   return { slug: post.node.sys.filename } }) // This would return an array like: [ { slug: 'HelloWorld.md'}, /.../ ]   For more information on manually writing queries for your specific schema, check out our "Writing Custom Queries" docs.  
> im the input The Local Filesystem-based Content API
2266c2828
< ![Editorial Workflow Setup](https://res.cloudinary.com/forestry-demo/image/upload/v1689016108/blog-media/editorial-workflow/enable-editorial-workflow.png)
---
> When developing locally, it's often beneficial to talk to the content on your local file-system, rather than talk to the hosted content API. Tina provides a CLI tool that lets you run the Content API locally next to your site. This allows all of your content to be made available through the same expressive GraphQL API during development.
2268c2830
< To set up the Editorial Workflow, follow these steps:
---
> > If you setup Tina via `@tinacms/cli init`, or used one of our starters, this should be setup by default. (Read about the CLI [here](/docs/graphql/cli/.)
2270,2273d2831
< 1. Go to the "Configuration" tab of your project in the dashboard.
< 2. Toggle the "Enable" option.
< 3. Enter the names of the branches you want to protect.
< 4. After setting up the protected branches, refresh your page to ensure the changes take effect.
2274a2833,2834
> im the output The Local Filesystem-based Content API  When developing locally, it's often beneficial to talk to the content on your local file-system, rather than talk to the hosted content API. Tina provides a CLI tool that lets you run the Content API locally next to your site. This allows all of your content to be made available through the same expressive GraphQL API during development.  If you setup Tina via @tinacms/cli init, or used one of our starters, this should be setup by default. (Read about the CLI here  
> im the input Video Tutorial
2276,2277c2836
< im the output Setting Up  The Editorial Workflow can be enabled in TinaCloud.    To set up the Editorial Workflow, follow these steps:  1. Go to the "Configuration" tab of your project in the dashboard. 2. Toggle the "Enable" option. 3. Enter the names of the branches you want to protect. 4. After setting up the protected branches, refresh your page to ensure the changes take effect.  
< im the input Accessing CMS and Saving to Protected Branches
---
> For those who prefer to learn from video, you can check out a snippet on "Data Fetching" from our ["TinaCMS Deep Dive"](https://www.youtube.com/watch?v=PcgnJDILv4w&list=PLPar4H9PHKVqoCwZy79PHr8-W_vA3lAOB&pp=iAQB) series.
2279c2838
< After completing the setup, you can access the CMS, and a new branch switcher button will appear at the top. When you are on a protected branch and click "Save," a modal will prompt you to enter the name of the new branch you wish to save to.
---
> <Youtube embedSrc="https://www.youtube.com/embed/PcgnJDILv4w?start=403&end=534" />
2281d2839
< ![Editorial Workflow Save](https://res.cloudinary.com/forestry-demo/image/upload/v1689033651/blog-media/editorial-workflow/create-branch_bgpgwn.png)
2283c2841,2842
< Once you enter the new branch name, the following actions will occur:
---
> im the output Video Tutorial  For those who prefer to learn from video, you can check out a snippet on "Data Fetching" from our "TinaCMS Deep Dive" series.  <Youtube embedSrc="https://www.youtube.com/embed/PcgnJDILv4w?start=403&end=534" / 
> im the input Summary
2285,2288c2844,2847
< - The new branch will be created.
< - The content of the new branch will be indexed (this process may take a few minutes).
< - The changes will be saved to the new branch.
< - A draft pull request will be created.
---
> - Tina provides a GraphQL API for querying your git-based content.
> - Tina provides a client that allows you to make type-safe requests to the Content API.
> - The client's "queries" property is generated based on _your_ schema.
> - A local version of the Content API can be used for local development.
2289a2849,2851
> im the output Summary  - Tina provides a GraphQL API for querying your git-based content. - Tina provides a client that allows you to make type-safe requests to the Content API. - The client's "queries" property is generated based on your schema. - A local version of the Content API can be used for local development. 
> im the input 
> The before submit function allows you to run a function on the frontend before the form is submitted to the backend and optionally modify the values of a document.
2291,2292d2852
< im the output Accessing CMS and Saving to Protected Branches  After completing the setup, you can access the CMS, and a new branch switcher button will appear at the top. When you are on a protected branch and click "Save," a modal will prompt you to enter the name of the new branch you wish to save to.    Once you enter the new branch name, the following actions will occur:  - The new branch will be created. - The content of the new branch will be indexed (this process may take a few minutes). - The changes will be saved to the new branch. - A draft pull request will be created.  
< im the input Publishing Content
2294c2854,2855
< When you are ready to publish your content, merge the draft pull request into the protected branch (e.g., main) through GitHub. After the pull request is successfully merged, the updated content will be available on the protected branch.
---
> im the output  The before submit function allows you to run a function on the frontend before the form is submitted to the backend and optionally modify the values of a document.  
> im the input Definition
2295a2857,2858
> ```ts
> import { TinaCMS, Form } from 'tinacms'
2297,2298c2860,2865
< im the output Publishing Content  When you are ready to publish your content, merge the draft pull request into the protected branch (e.g., main) through GitHub. After the pull request is successfully merged, the updated content will be available on the protected branch.  
< im the input GitHub Pull Request links
---
> type BeforeSubmitFunction = (args: {
>   values: Record<string, unknown>
>   cms: TinaCMS
>   form: Form
> }) => Promise<void | Record<string, unknown>>
> ```
2300d2866
< In the branch list modal, you can click on the dropdown and click "View Pull Request" to view the pull request on GitHub. This will open a new tab in your browser. This link will only aprear of the pull request has been created with TinaCMS and not if it was created manually.
2302c2868,2869
< ![PR Links](https://res.cloudinary.com/forestry-demo/image/upload/v1689082820/blog-media/editorial-workflow/preview-link.png)
---
> im the output Definition  ts import { TinaCMS, Form } from 'tinacms'  type BeforeSubmitFunction = (args: {   values: Record<string, unknown  cms: TinaCMS   form: Form }) =Promise<void | Record<string, unknown  
> im the input Examples
2303a2871,2873
> #
> im the output Examples  #
> im the input Adding a last updated field
2305,2313d2874
< im the output GitHub Pull Request links  In the branch list modal, you can click on the dropdown and click "View Pull Request" to view the pull request on GitHub. This will open a new tab in your browser. This link will only aprear of the pull request has been created with TinaCMS and not if it was created manually.    
< im the input Preview links
< 
< You can setup preview links for your pull requests.
< 
< ![Editorial Workflow Save](https://res.cloudinary.com/forestry-demo/image/upload/v1689035096/blog-media/editorial-workflow/share-btn_xvmxii.png)
< 
< This will allow you to preview your content changes before merging them into the protected branch. To setup preview links, In your config file add a `previewUrl` function to the `ui` object. This function will receive the branch name as an argument and should return the preview url for that branch. For example:
< 
2315c2876
< // tina/config.{ts,tsx,js}
---
> // tina/config.{ts.js}
2318,2325c2879,2903
<   // ...
<   ui: {
<     // Eg. If you're deplying to Vercel, and your repo name is 'my-app', Vercel's preview URL would be based on the branch:
<     previewUrl: (context) => {
<       const repoName = 'my-app'
<       // `https://<project-name>-git-<branch-name>.vercel.app`
<       return { url: `https://my-app-git-${context.branch}` }
<     },
---
>   schema: {
>     collections: [
>       {
>         ui: {
>           // Example of beforeSubmit
>           beforeSubmit: async ({
>             form,
>             cms,
>             values,
>           }: {
>             form: Form
>             cms: TinaCMS
>             values: Record<string, any>
>           }) => {
>             return {
>               ...values,
>               lastUpdated: new Date().toISOString(),
>             }
>           },
>           //...
>         },
>         //...
>       },
>       //...
>     ],
2331,2395c2909,2911
< Now you will be able to click on the "View Preview" button in the branch list modal to preview your changes.
< 
< im the output Preview links  You can setup preview links for your pull requests.    This will allow you to preview your content changes before merging them into the protected branch. To setup preview links, In your config file add a previewUrl function to the ui object. This function will receive the branch name as an argument and should return the preview url for that branch. For example:  js // tina/config.{ts,tsx,js}  export default defineConfig({   // ...   ui: {     // Eg. If you're deplying to Vercel, and your repo name is 'my-app', Vercel's preview URL would be based on the branch:     previewUrl: (context) ={       const repoName = 'my-app'       // https://<project-name-git-<branch-name.vercel.app       return { url: https://my-app-git-${context.branch} }     },   },   //... })   Now you will be able to click on the "View Preview" button in the branch list modal to preview your changes. 
< im the input 
< TinaCMS supports a few implementations of "drafts".
< 
< 
< im the output  TinaCMS supports a few implementations of "drafts".  
< im the input Document-based "draft" state
< 
< Developers can setup a "draft" field on a document, which can be toggled to conditionally include pages based on their draft state.
< 
< [Read more about implementing a "draft field" here](/docs/drafts/drafts-fields)
< 
< 
< im the output Document-based "draft" state  Developers can setup a "draft" field on a document, which can be toggled to conditionally include pages based on their draft state.  Read more about implementing a "draft field" here  
< im the input Working in branches
< 
< Some editorial teams like to work in branches, for more control over what gets merged into production.
< 
< In these cases, you may want to have your editors work from your hosting provider's preview deployments, instead of `<your-production-site>/admin`.
< 
< See our [TinaCloud Docs](/docs/tina-cloud/dashboard/projects/#glob-patterns) for help setting this up.
< 
< im the output Working in branches  Some editorial teams like to work in branches, for more control over what gets merged into production.  In these cases, you may want to have your editors work from your hosting provider's preview deployments, instead of <your-production-site/admin.  See our TinaCloud Docs for help setting this up. 
< im the input 
< For most simple cases, you should be able to leverage the Tina Client's generated queries to do your data fetching:
< 
< ```ts
< const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
< ```
< 
< In more advanced cases, you may want more control on the underlying GraphQL query. In these cases you have two options:
< 
< * Extending the auto-generated `client.queries` by writing a custom query.
< * Use `client.request`, and write an inline query.
< 
< 
< im the output  For most simple cases, you should be able to leverage the Tina Client's generated queries to do your data fetching:  ts const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })   In more advanced cases, you may want more control on the underlying GraphQL query. In these cases you have two options:   Extending the auto-generated client.queries by writing a custom query.  Use client.request, and write an inline query.  
< im the input Extending the auto-generated `client.queries`
< 
< The client can be extended to perform more advanced queries (including querying multiple root collections at once), by adding queries to the `tina/queries` directory. All files that end in `gql` or `graphql` in this directory will be added to the client.
< 
< Tina generates custom [GraphQL fragments](https://graphql.org/learn/queries/#fragments) to be used in custom queries so that the queries will not have to be updated when the schema is updated.
< 
< > Note: These fragments can be seen in `tina/__generated__/frags.gql`
< 
< Example of `tina/queries/postWithNav.gql`:
< 
< ```ts
< query postWithNav($relativePath: String!) {
<   nav(relativePath: "nav.json") {
<     ...NavParts
<   }
<   post(relativePath: $relativePath) {
<     ...PostParts
<   }
< }
< ```
< 
< To get autocomplete in your GraphQL files add a [`graphql.config.js`](https://github.com/tinacms/tina-cloud-starter/blob/main/graphql.config.js) that points to `tina/__generated__/schema.gql` and `tina/__generated__/frags.gql`.
< 
< > Note: fragments are named by using the collection name (capitalized) followed by "Parts"
< 
< We are using a `PostParts` & `NavParts` Fragment here. For each collection, this fragment is generated and updated when the schema is updated. You can view any available Fragments for your schema in `/tina/__generated__/frags.gql`.
---
> #
> im the output Adding a last updated field  js // tina/config.{ts.js}  export default defineConfig({   schema: {     collections: [       {         ui: {           // Example of beforeSubmit           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             return {               ...values,               lastUpdated: new Date().toISOString(),             }           },           //...         },         //...       },       //...     ],   },   //... })   #
> im the input Adding a created at field
2397,2398d2912
< Once the query is added, the client will have its types updated so that it can be used to request the new query.
< 
2400,2405c2914,2942
< import { client } from '../[pathToTina]/tina/__generated__/client'
< 
< // Use the client to perform data fetching
< // Here, it fetches a single "post" item
< const myPost = await client.queries.postWithNav({
<   relativePath: 'HelloWorld.md',
---
> export default defineConfig({
>   schema: {
>     collections: [
>       {
>         ui: {
>           beforeSubmit: async ({
>             form,
>             cms,
>             values,
>           }: {
>             form: Form
>             cms: TinaCMS
>             values: Record<string, any>
>           }) => {
>             if (form.crudType === 'create') {
>               return {
>                 ...values,
>                 createdAt: new Date().toISOString(),
>               }
>             }
>           },
>           //...
>         },
>         //...
>       },
>       //...
>     ],
>   },
>   //...
2406a2944
> ```
2408,2409c2946,2981
< console.log(myPost.title)
< console.log(myPost.nav.items)
---
> #
> im the output Adding a created at field  js export default defineConfig({   schema: {     collections: [       {         ui: {           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             if (form.crudType === 'create') {               return {                 ...values,                 createdAt: new Date().toISOString(),               }             }           },           //...         },         //...       },       //...     ],   },   //... })   #
> im the input Adding a slug field
> 
> ```js
> export default defineConfig({
>   schema: {
>     collections: [
>       {
>         ui: {
>           beforeSubmit: async ({
>             form,
>             cms,
>             values,
>           }: {
>             form: Form
>             cms: TinaCMS
>             values: Record<string, any>
>           }) => {
>             return {
>               ...values,
>               slug: values.title
>                 .toLowerCase()
>                 .replace(/ /g, '-')
>                 .replace(/[^\w-]+/g, ''),
>             }
>           },
>           //...
>         },
>         //...
>       },
>       //...
>     ],
>   },
>   //...
> })
2411a2984,2986
> im the output Adding a slug field  js export default defineConfig({   schema: {     collections: [       {         ui: {           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             return {               ...values,               slug: values.title                 .toLowerCase()                 .replace(/ /g, '-')                 .replace(/[^\w-]+/g, ''),             }           },           //...         },         //...       },       //...     ],   },   //... })  
> im the input 
> A custom component can be passed and rendered by setting the `ui.component` property on a field. This component completely overrides the original component, providing the user with the ability to fully customize the field.
2413,2414d2987
< im the output Extending the auto-generated client.queries  The client can be extended to perform more advanced queries (including querying multiple root collections at once), by adding queries to the tina/queries directory. All files that end in gql or graphql in this directory will be added to the client.  Tina generates custom GraphQL fragments to be used in custom queries so that the queries will not have to be updated when the schema is updated.  Note: These fragments can be seen in tina/generated/frags.gql  Example of tina/queries/postWithNav.gql:  ts query postWithNav($relativePath: String!) {   nav(relativePath: "nav.json") {     ...NavParts   }   post(relativePath: $relativePath) {     ...PostParts   } }   To get autocomplete in your GraphQL files add a graphql.config.js that points to tina/generated/schema.gql and tina/generated/frags.gql.  Note: fragments are named by using the collection name (capitalized) followed by "Parts"  We are using a PostParts & NavParts Fragment here. For each collection, this fragment is generated and updated when the schema is updated. You can view any available Fragments for your schema in /tina/generated/frags.gql.  Once the query is added, the client will have its types updated so that it can be used to request the new query.  js import { client } from '../[pathToTina]/tina/generated/client'  // Use the client to perform data fetching // Here, it fetches a single "post" item const myPost = await client.queries.postWithNav({   relativePath: 'HelloWorld.md', })  console.log(myPost.title) console.log(myPost.nav.items)   
< im the input Writing inline queries
2416c2989,2990
< If you want to avoid using the types on the client altogether, you can also just write an inline query using the `client.request` function.
---
> im the output  A custom component can be passed and rendered by setting the ui.component property on a field. This component completely overrides the original component, providing the user with the ability to fully customize the field.  
> im the input Providing your own component
2418,2419c2992
< ```js
< import { client } from '../[pathToTina]/tina/__generated__/client'
---
> A field's `ui.component` property is a React component that accepts three props:
2421,2431c2994,2996
< // Use the client to perform data fetching
< // Here, it fetches a single "post" item
< const myPost = await client.request({
<   query: `query getPost($relativePath: String!) {
<       post(relativePath: $relativePath) {
<         title
<         body
<       }
<     `,
<   variables: { relativePath: 'hello-world.md' },
< })
---
> - `field`: The [field definition](https://tinacms.org/docs/reference/toolkit/fields) for the current field.
> - `input`: The data and callbacks necessary to make an input.
> - `meta`: Metadata about the field in the form. (e.g. `dirty`, `valid`)
2433c2998,3040
< console.log(myPost.title)
---
> Checkout the [react-final-form](https://github.com/final-form/react-final-form#fieldrenderprops) docs for a more detailed description of the `input` and `meta` props.
> 
> #
> im the output Providing your own component  A field's ui.component property is a React component that accepts three props:  - field: The field definition for the current field. - input: The data and callbacks necessary to make an input. - meta: Metadata about the field in the form. (e.g. dirty, valid)  Checkout the react-final-form docs for a more detailed description of the input and meta props.  #
> im the input Custom Component Example
> 
> Here is a custom slider component that can be used for adjusting image saturation.
> 
> ![A basic slider custom component](https://res.cloudinary.com/forestry-demo/image/upload/v1652976482/tina-io/docs/extending-tina/image-saturation.png)
> 
> ```tsx
> import { defineConfig, wrapFieldsWithMeta } from 'tinacms'
> 
> //.. other fields
> {
>   label: "Image Saturation",
>   name: "saturation",
>   type: "number",
>   description: "My custom saturation field",
>   ui: {
>     parse: (val) => Number(val),
> 
>     // wrapping our component in wrapFieldsWithMeta renders our label & description.
>     component: wrapFieldsWithMeta(({ field, input, meta }) => {
>       return (
>         <div>
>           <input
>             name="saturation"
>             id="saturation"
>             type="range"
>             min="0"
>             max="10"
>             step=".1"
>             // This will pass along props.input.onChange to set our form values as this input changes.
>             {...input}
>           />
>           <br />
>           Value: {input.value}
>         </div>
>       )
>     })
>   }
> }
2436c3043
< For more information on writing custom queries, check out the [querying reference docs](/docs/graphql/queries/).
---
> > Note: in this example, `parse` is also needed. [Read more about `parse`](/docs/extending-tina/format-and-parse/).
2438,2439d3044
< im the output Writing inline queries  If you want to avoid using the types on the client altogether, you can also just write an inline query using the client.request function.  js import { client } from '../[pathToTina]/tina/generated/client'  // Use the client to perform data fetching // Here, it fetches a single "post" item const myPost = await client.request({   query: query getPost($relativePath: String!) {       post(relativePath: $relativePath) {         title         body       }     ,   variables: { relativePath: 'hello-world.md' }, })  console.log(myPost.title)   For more information on writing custom queries, check out the querying reference docs. 
< im the input 
2441,2443c3046,3047
< im the output  
< im the input Introduction
< As mentioned in [Introduction to Data fetching](/docs/features/data-fetching/), Tina provides a client for querying content.
---
> im the output Custom Component Example  Here is a custom slider component that can be used for adjusting image saturation.    tsx import { defineConfig, wrapFieldsWithMeta } from 'tinacms'  //.. other fields {   label: "Image Saturation",   name: "saturation",   type: "number",   description: "My custom saturation field",   ui: {     parse: (val) =Number(val),      // wrapping our component in wrapFieldsWithMeta renders our label & description.     component: wrapFieldsWithMeta(({ field, input, meta }) ={       return (         <div          <input             name="saturation"             id="saturation"             type="range"             min="0"             max="10"             step=".1"             // This will pass along props.input.onChange to set our form values as this input changes.             {...input}           /          <br /          Value: {input.value}         </div      )     })   } }   Note: in this example, parse is also needed. Read more about parse.  
> im the input Using pre-built components
2445c3049
< > Note, for advanced use-cases, you can also manually query the underlying [GraphQL API](/docs/data-fetching/custom-queries/#writing-inline-queries).
---
> Tina also provides a variety of pre-built components. To specify these, the `ui.component` property should be configured with the string name of the registered field plugin.
2446a3051
> Below is a list of default fields.
2448,2449c3053,3055
< im the output Introduction As mentioned in Introduction to Data fetching, Tina provides a client for querying content.  Note, for advanced use-cases, you can also manually query the underlying GraphQL API.  
< im the input Querying a single document
---
> #
> im the output Using pre-built components  Tina also provides a variety of pre-built components. To specify these, the ui.component property should be configured with the string name of the registered field plugin.  Below is a list of default fields.  #
> im the input Default Field Plugins
2451,2452c3057,3070
< ```js
< import { client } from '../[pathToTina]/tina/__generated__/client'
---
> - [text](/docs/reference/toolkit/fields/text/)
> - [textarea](/docs/reference/toolkit/fields/textarea/)
> - [number](/docs/reference/toolkit/fields/number/)
> - [image](/docs/reference/toolkit/fields/image/)
> - [color](/docs/reference/toolkit/fields/color/)
> - [toggle](/docs/reference/toolkit/fields/toggle/)
> - [radio-group](/docs/reference/toolkit/fields/radio-group/)
> - [select](/docs/reference/toolkit/fields/select/)
> - [tags](/docs/reference/toolkit/fields/tags/)
> - [list](/docs/reference/toolkit/fields/list/)
> - [group](/docs/reference/toolkit/fields/group/)
> - [group-list](/docs/reference/toolkit/fields/group-list/)
> - [blocks](/docs/reference/toolkit/fields/blocks/)
> - [date](/docs/reference/toolkit/fields/date/)
2454c3072
< const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
---
> Tina also supports some add-on field plugins. These need to be imported and registered from separate packages:
2456c3074,3096
< console.log(myPost.title)
---
> - [markdown](/docs/reference/toolkit/fields/markdown/)
> - [html](/docs/reference/toolkit/fields/html/)
> 
> #
> im the output Default Field Plugins  - text - textarea - number - image - color - toggle - radio-group - select - tags - list - group - group-list - blocks - date  Tina also supports some add-on field plugins. These need to be imported and registered from separate packages:  - markdown - html  #
> im the input Configuring a field plugin
> 
> Each field has a unique set of properties that can be configured within the schema.
> 
> For example, if you take a look at the color field plugin's definition, it takes a `colorFormat` property. We can configure that in our schema like so:
> 
> ```ts
> // ...
>         {
>           type: 'string',
>           label: 'Background Color',
>           name: 'color',
>           ui: {
>             component: "color",
>             colorFormat: "rgb"
>           }
>         },
> // ...
2459d3098
< In the above example `post` is the name of the collection being queried. This can be replaced with one of your schema's defined collection names.
2460a3100,3101
> im the output Configuring a field plugin  Each field has a unique set of properties that can be configured within the schema.  For example, if you take a look at the color field plugin's definition, it takes a colorFormat property. We can configure that in our schema like so:  ts // ...         {           type: 'string',           label: 'Background Color',           name: 'color',           ui: {             component: "color",             colorFormat: "rgb"           }         }, // ...   
> im the input Video Tutorial
2462,2608c3103,3116
< im the output Querying a single document  js import { client } from '../[pathToTina]/tina/generated/client'  const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })  console.log(myPost.title)   In the above example post is the name of the collection being queried. This can be replaced with one of your schema's defined collection names.  
< im the input Querying a list of documents
< 
< ```js
< const postsResponse = await client.queries.postConnection()
< const posts = postsResponse.data.postConnection.edges.map((post) => {
<   return { slug: post.node._sys.filename }
< })
< // This would return an array like: [ { slug: 'HelloWorld.md'}, /*...*/ ]
< ```
< 
< `<collection-name>Connection` can be used to query a list of documents (in the above example, our collection name is `post`).
< 
< #
< im the output Querying a list of documents  js const postsResponse = await client.queries.postConnection() const posts = postsResponse.data.postConnection.edges.map((post) ={   return { slug: post.node.sys.filename } }) // This would return an array like: [ { slug: 'HelloWorld.md'}, /.../ ]   <collection-nameConnection can be used to query a list of documents (in the above example, our collection name is post).  #
< im the input Filtering
< 
< Filters can be added as an option to your `<collection-name>Collection` query.
< 
< ```js
< const postsResponse = await client.queries.postConnection({
<   filter: { title: { startsWith: 'Vote' } },
< })
< 
< // ...
< ```
< 
< The following operator types are available for querying
< 
< | Key        | Behavior                 | Type(s)                          |
< | :--------- | ------------------------ | -------------------------------- |
< | eq         | Equals                   | string, number, boolean          |
< | in         | One of                   | string\[], number\[], boolean\[] |
< | gt         | Greater than             | string, number                   |
< | gte        | Greater than or equal to | string, number                   |
< | lt         | Less than                | string, number                   |
< | lte        | Less than or equal to    | string, number                   |
< | startsWith | Starts with              | string                           |
< | after      | After                    | datetime                         |
< | before     | Before                   | datetime                         |
< 
< > Only `gt`, `gte`, `lt`, `lte`, `after`, `before` may be used in ternary conditions.
< 
< #
< im the output Filtering  Filters can be added as an option to your <collection-nameCollection query.  js const postsResponse = await client.queries.postConnection({   filter: { title: { startsWith: 'Vote' } }, })  // ...   The following operator types are available for querying  | Key        | Behavior                 | Type(s)                          | | : |  |  | | eq         | Equals                   | string, number, boolean          | | in         | One of                   | string\[], number\[], boolean\[] | | gt         | Greater than             | string, number                   | | gte        | Greater than or equal to | string, number                   | | lt         | Less than                | string, number                   | | lte        | Less than or equal to    | string, number                   | | startsWith | Starts with              | string                           | | after      | After                    | datetime                         | | before     | Before                   | datetime                         |  Only gt, gte, lt, lte, after, before may be used in ternary conditions.  #
< im the input Sorting
< 
< Sorting can be added as an option to your `<collection-name>Collection` query.
< 
< ```js
< const postsResponse = await client.queries.postConnection({
<   sort: 'date',
< })
< 
< // ...
< ```
< 
< ##
< im the output Sorting  Sorting can be added as an option to your <collection-nameCollection query.  js const postsResponse = await client.queries.postConnection({   sort: 'date', })  // ...   ##
< im the input Sorting on multiple fields
< 
< Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:
< 
< ```js
< const postsResponse = await client.queries.postConnection({
<   sort: 'category-date',
< })
< 
< // ...
< ```
< 
< #
< im the output Sorting on multiple fields  Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:  js const postsResponse = await client.queries.postConnection({   sort: 'category-date', })  // ...   #
< im the input Pagination
< 
< Tina supports cursor-based pagination:
< 
< ```js
< const postsResponse = await client.queries.postConnection({
<   first: 10,
<   after:
<     'cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==',
< })
< 
< // ...
< ```
< 
< One caveat to using the built-in queries on the client is that **you can only query one root collection at a time**. If you have a page that has multiple forms on it, you may need to use [custom queries](/docs/data-fetching/custom-queries/).
< 
< im the output Pagination  Tina supports cursor-based pagination:  js const postsResponse = await client.queries.postConnection({   first: 10,   after:     'cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==', })  // ...   One caveat to using the built-in queries on the client is that you can only query one root collection at a time. If you have a page that has multiple forms on it, you may need to use custom queries. 
< im the input 
< This error happens when a collection uses templates and there is no template key found in the document. It is common for this to happen when migrating from fields to templates or during forestry migration.
< 
< 
< im the output  This error happens when a collection uses templates and there is no template key found in the document. It is common for this to happen when migrating from fields to templates or during forestry migration.  
< im the input How to fix
< 
< This error can be fixed by adding a root level field of \_template to every document with this error.  There is not currently any way to automatically migrate the content and it must be done manually or with custom scripts.
< 
< Ex:
< If you had a markdown file you would add:
< 
< ```markdown
< ---
< _template: templateName
< ---
< ```
< 
< Where `templateName` is the name of the template in your collection
< 
< If it was a JSON file it would look like this.
< 
< ```json
< {
<   "_template": "templateName",
< }
< ```
< 
< etc.
< 
< [Check out this video](https://www.loom.com/share/077e2a626f4246b1b680526433ef1e33?sid=612ce485-d386-479b-a9c2-1de55ec6f24c "Ambiguous Template Video") for a deeper explanation.
< 
< im the output How to fix  This error can be fixed by adding a root level field of \template to every document with this error.  There is not currently any way to automatically migrate the content and it must be done manually or with custom scripts.  Ex: If you had a markdown file you would add:  markdown  template: templateName    Where templateName is the name of the template in your collection  If it was a JSON file it would look like this.  json {   "template": "templateName", }   etc.  Check out this video for a deeper explanation. 
< im the input 
< The `tina/config.{ts,js,tsx}` file is built with [esbuild](https://esbuild.github.io/) and executed in a node.js runtime. This allows you to import from outside your `.tina` folder and esbuild will handle this for us. This also can run into some edge cases where some things are being run on the server that should not be.
< 
< 
< im the output  The tina/config.{ts,js,tsx} file is built with esbuild and executed in a node.js runtime. This allows you to import from outside your .tina folder and esbuild will handle this for us. This also can run into some edge cases where some things are being run on the server that should not be.  
< im the input ERROR: your schema was not successfully built
< 
< This means that there was a syntax or semantic error somewhere in your code. This could be inside the .tina folder or in any file that was imported from your schema file.
< 
< 
< im the output ERROR: your schema was not successfully built  This means that there was a syntax or semantic error somewhere in your code. This could be inside the .tina folder or in any file that was imported from your schema file.  
< im the input ERROR: your config.{ts,js} was not successfully executed
< 
< This error means that the schema was compiled correctly (correct syntax) but when the code was run it produced an error.
< 
< Some common issues are
< 
< - Importing code that requires a custom compile logic (webpack loader, esbuild loader, babel plugin, etc)
< - Importing and running code that needs to be run on the frontend (uses `window`, DOM APIs, etc)
< 
< If you run into one of the above issues you can try only importing the code that you need.
< 
< For example you might have
< 
---
> For those who prefer to learn from video, you can check out a snippet on "Customizing Components" from our ["TinaCMS Deep Dive"](https://www.youtube.com/watch?v=PcgnJDILv4w&list=PLPar4H9PHKVqoCwZy79PHr8-W_vA3lAOB&pp=iAQB) series.
> 
> <Youtube embedSrc="https://www.youtube.com/embed/amSRwAbgMR0?start=744" />
> 
> im the output Video Tutorial  For those who prefer to learn from video, you can check out a snippet on "Customizing Components" from our "TinaCMS Deep Dive" series.  <Youtube embedSrc="https://www.youtube.com/embed/amSRwAbgMR0?start=744" /
> im the input 
> If list is `true` the default label is often not very useful to editors.
> 
> ![list UI](https://res.cloudinary.com/forestry-demo/image/upload/v1649941182/tina-io/docs/extending-tina/Extending_Tina_No_List_Props.png)
> 
> The label used for list items can be customized using the `itemProps` function. The main use-case for this is to provide a custom label based on the data in the component.
> 
> For example, to use the `title` field as the label for this image gallery collection:
> 
2610,3032d3117
< import { TinaHeroTemplate } from '../components/'
< ```
< 
< which could be switched to
< 
< ```ts
< import { TinaHeroTemplate } from '../components/blocks/hero'
< ```
< 
< Using this more specific path means it is less likely that you will run into errors
< 
< Still confused? Don't worry we are here to help please [reach out to us on discord](https://discord.gg/njvZZYHj2Q) or submit a [github issue](https://github.com/tinacms/tinacms/issues/new/choose) and we will get back to you as soon as possible.
< 
< im the output ERROR: your config.{ts,js} was not successfully executed  This error means that the schema was compiled correctly (correct syntax) but when the code was run it produced an error.  Some common issues are  - Importing code that requires a custom compile logic (webpack loader, esbuild loader, babel plugin, etc) - Importing and running code that needs to be run on the frontend (uses window, DOM APIs, etc)  If you run into one of the above issues you can try only importing the code that you need.  For example you might have  ts import { TinaHeroTemplate } from '../components/'   which could be switched to  ts import { TinaHeroTemplate } from '../components/blocks/hero'   Using this more specific path means it is less likely that you will run into errors  Still confused? Don't worry we are here to help please reach out to us on discord and we will get back to you as soon as possible. 
< im the input 
< This error occurs when a file is in multiple collections. This is usually caused by overlapping paths in in your collections or an error in a [match property](/docs/reference/collections#matchinclude).
< 
< The common fix for this is updating or adding the [match property](/docs/reference/collections#matchinclude) to exclude or include certain files.
< 
< 
< im the output  This error occurs when a file is in multiple collections. This is usually caused by overlapping paths in in your collections or an error in a match property.  The common fix for this is updating or adding the match property to exclude or include certain files.  
< im the input Example with exclude
< 
< ```ts
< // tina/schema.ts
< export default defineConfig({
<   collections: [
<     {
<       label: 'Blog Posts',
<       name: 'posts',
<       path: 'content/posts',
<       // ..
<     },
<     {
<       label: 'Featured Posts',
<       name: 'featuredPosts',
<       path: 'content/posts/featured',
<       // ...
<     },
<     //..
<   ],
<   // ...
< })
< ```
< 
< The example configuration above would cause an overlap because the Blog Post collection will contain all of the files in the Featured Posts collection. This can be fixed by updating the [`match.exclude` property](/docs/reference/collections#matchexclude) on the Blog Posts collection to exclude all of the files in the Features Posts collection.
< 
< ```ts
< // tina/schema.ts
< export default defineConfig({
<   collections: [
<     {
<       label: 'Blog Posts',
<       name: 'posts',
<       path: 'content/posts',
<       match: {
<         exclude: 'featured/**/**',
<       },
<       // ..
<     },
<     {
<       label: 'Featured Posts',
<       name: 'featuredPosts',
<       path: 'content/posts/featured',
<       // ...
<     },
<     //..
<   ],
<   // ...
< })
< ```
< 
< 
< im the output Example with exclude  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       // ..     },     {       label: 'Featured Posts',       name: 'featuredPosts',       path: 'content/posts/featured',       // ...     },     //..   ],   // ... })   The example configuration above would cause an overlap because the Blog Post collection will contain all of the files in the Featured Posts collection. This can be fixed by updating the match.exclude property on the Blog Posts collection to exclude all of the files in the Features Posts collection.  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       match: {         exclude: 'featured//',       },       // ..     },     {       label: 'Featured Posts',       name: 'featuredPosts',       path: 'content/posts/featured',       // ...     },     //..   ],   // ... })   
< im the input Example with include
< 
< An example of include could be if you only wanted to include files with a certain name. For example if you wanted to include all of the files in the `content/posts` directory that had the name `index`.
< 
< ```ts
< // tina/schema.ts
< export default defineConfig({
<   collections: [
<     {
<       label: 'Blog Posts',
<       name: 'posts',
<       path: 'content/posts',
<       match: {
<         include: '**/**/index',
<       },
<       // ..
<     },
<     //..
<   ],
<   // ...
< })
< ```
< 
< im the output Example with include  An example of include could be if you only wanted to include files with a certain name. For example if you wanted to include all of the files in the content/posts directory that had the name index.  ts // tina/schema.ts export default defineConfig({   collections: [     {       label: 'Blog Posts',       name: 'posts',       path: 'content/posts',       match: {         include: '//index',       },       // ..     },     //..   ],   // ... })  
< im the input 
< We have expanded the graphql API capabilities to to have a [`list` property](/docs/schema/#the-list-property) option for every field. This means that the graphql response will return a array for of [`type`](/docs/schema/#the-type-property) for this field. This is support on our backend but we still have not implanted the front end user interface for these fields yet. [Here is the relevant issue for tracking](https://github.com/tinacms/tinacms/issues/2081). There are currently two workarounds for this issue.
< 
< 
< im the output  We have expanded the graphql API capabilities to to have a list property. There are currently two workarounds for this issue.  
< im the input 1. Wrap in object field
< 
< Wrap in an [`object` field](/docs/schema/#the-object-property). If your field looked like this
< 
< ```js
< {
<     type: "image",
<     name: "images",
<     label: "Images",
<     list: true,
< }
< ```
< 
< This can be used instead
< 
< ```js
< {
<     type: "object",
<     name: "images",
<     label: "Images",
<     list: true,
<     fields: [
<         {
<             type: "image",
<             name: "image",
<             label: "A single image",
<         }
<     ]
< }
< ```
< 
< Now you will be able to and delete new images in a list.
< 
< 
< im the output 1. Wrap in object field  Wrap in an object field. If your field looked like this  js {     type: "image",     name: "images",     label: "Images",     list: true, }   This can be used instead  js {     type: "object",     name: "images",     label: "Images",     list: true,     fields: [         {             type: "image",             name: "image",             label: "A single image",         }     ] }   Now you will be able to and delete new images in a list.  
< im the input 2. Create your own custom UI
< 
< You can create your own custom user interface by adding a [custom field](/docs/extending-tina/custom-field-components). You will have to make your own component that follows that type in the schema. After that is done your field could look like this.
< 
< ```js
< {
<     type: "image",
<     name: "images",
<     label: "Images",
<     list: true,
<     ui: {
<         component: "MyCustomImageListingField",
<     }
< }
< ```
< 
< im the output 2. Create your own custom UI  You can create your own custom user interface by adding a custom field. You will have to make your own component that follows that type in the schema. After that is done your field could look like this.  js {     type: "image",     name: "images",     label: "Images",     list: true,     ui: {         component: "MyCustomImageListingField",     } }  
< im the input 
< The before submit function allows you to run a function on the frontend before the form is submitted to the backend and optionally modify the values of a document.
< 
< 
< im the output  The before submit function allows you to run a function on the frontend before the form is submitted to the backend and optionally modify the values of a document.  
< im the input Definition
< 
< ```ts
< import { TinaCMS, Form } from 'tinacms'
< 
< type BeforeSubmitFunction = (args: {
<   values: Record<string, unknown>
<   cms: TinaCMS
<   form: Form
< }) => Promise<void | Record<string, unknown>>
< ```
< 
< 
< im the output Definition  ts import { TinaCMS, Form } from 'tinacms'  type BeforeSubmitFunction = (args: {   values: Record<string, unknown  cms: TinaCMS   form: Form }) =Promise<void | Record<string, unknown  
< im the input Examples
< 
< #
< im the output Examples  #
< im the input Adding a last updated field
< 
< ```js
< // tina/config.{ts.js}
< 
< export default defineConfig({
<   schema: {
<     collections: [
<       {
<         ui: {
<           // Example of beforeSubmit
<           beforeSubmit: async ({
<             form,
<             cms,
<             values,
<           }: {
<             form: Form
<             cms: TinaCMS
<             values: Record<string, any>
<           }) => {
<             return {
<               ...values,
<               lastUpdated: new Date().toISOString(),
<             }
<           },
<           //...
<         },
<         //...
<       },
<       //...
<     ],
<   },
<   //...
< })
< ```
< 
< #
< im the output Adding a last updated field  js // tina/config.{ts.js}  export default defineConfig({   schema: {     collections: [       {         ui: {           // Example of beforeSubmit           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             return {               ...values,               lastUpdated: new Date().toISOString(),             }           },           //...         },         //...       },       //...     ],   },   //... })   #
< im the input Adding a created at field
< 
< ```js
< export default defineConfig({
<   schema: {
<     collections: [
<       {
<         ui: {
<           beforeSubmit: async ({
<             form,
<             cms,
<             values,
<           }: {
<             form: Form
<             cms: TinaCMS
<             values: Record<string, any>
<           }) => {
<             if (form.crudType === 'create') {
<               return {
<                 ...values,
<                 createdAt: new Date().toISOString(),
<               }
<             }
<           },
<           //...
<         },
<         //...
<       },
<       //...
<     ],
<   },
<   //...
< })
< ```
< 
< #
< im the output Adding a created at field  js export default defineConfig({   schema: {     collections: [       {         ui: {           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             if (form.crudType === 'create') {               return {                 ...values,                 createdAt: new Date().toISOString(),               }             }           },           //...         },         //...       },       //...     ],   },   //... })   #
< im the input Adding a slug field
< 
< ```js
< export default defineConfig({
<   schema: {
<     collections: [
<       {
<         ui: {
<           beforeSubmit: async ({
<             form,
<             cms,
<             values,
<           }: {
<             form: Form
<             cms: TinaCMS
<             values: Record<string, any>
<           }) => {
<             return {
<               ...values,
<               slug: values.title
<                 .toLowerCase()
<                 .replace(/ /g, '-')
<                 .replace(/[^\w-]+/g, ''),
<             }
<           },
<           //...
<         },
<         //...
<       },
<       //...
<     ],
<   },
<   //...
< })
< ```
< 
< im the output Adding a slug field  js export default defineConfig({   schema: {     collections: [       {         ui: {           beforeSubmit: async ({             form,             cms,             values,           }: {             form: Form             cms: TinaCMS             values: Record<string, any          }) ={             return {               ...values,               slug: values.title                 .toLowerCase()                 .replace(/ /g, '-')                 .replace(/[^\w-]+/g, ''),             }           },           //...         },         //...       },       //...     ],   },   //... })  
< im the input 
< A custom component can be passed and rendered by setting the `ui.component` property on a field. This component completely overrides the original component, providing the user with the ability to fully customize the field.
< 
< 
< im the output  A custom component can be passed and rendered by setting the ui.component property on a field. This component completely overrides the original component, providing the user with the ability to fully customize the field.  
< im the input Providing your own component
< 
< A field's `ui.component` property is a React component that accepts three props:
< 
< - `field`: The [field definition](https://tinacms.org/docs/reference/toolkit/fields) for the current field.
< - `input`: The data and callbacks necessary to make an input.
< - `meta`: Metadata about the field in the form. (e.g. `dirty`, `valid`)
< 
< Checkout the [react-final-form](https://github.com/final-form/react-final-form#fieldrenderprops) docs for a more detailed description of the `input` and `meta` props.
< 
< #
< im the output Providing your own component  A field's ui.component property is a React component that accepts three props:  - field: The field definition for the current field. - input: The data and callbacks necessary to make an input. - meta: Metadata about the field in the form. (e.g. dirty, valid)  Checkout the react-final-form docs for a more detailed description of the input and meta props.  #
< im the input Custom Component Example
< 
< Here is a custom slider component that can be used for adjusting image saturation.
< 
< ![A basic slider custom component](https://res.cloudinary.com/forestry-demo/image/upload/v1652976482/tina-io/docs/extending-tina/image-saturation.png)
< 
< ```tsx
< import { defineConfig, wrapFieldsWithMeta } from 'tinacms'
< 
< //.. other fields
< {
<   label: "Image Saturation",
<   name: "saturation",
<   type: "number",
<   description: "My custom saturation field",
<   ui: {
<     parse: (val) => Number(val),
< 
<     // wrapping our component in wrapFieldsWithMeta renders our label & description.
<     component: wrapFieldsWithMeta(({ field, input, meta }) => {
<       return (
<         <div>
<           <input
<             name="saturation"
<             id="saturation"
<             type="range"
<             min="0"
<             max="10"
<             step=".1"
<             // This will pass along props.input.onChange to set our form values as this input changes.
<             {...input}
<           />
<           <br />
<           Value: {input.value}
<         </div>
<       )
<     })
<   }
< }
< ```
< 
< > Note: in this example, `parse` is also needed. [Read more about `parse`](/docs/extending-tina/format-and-parse/).
< 
< 
< im the output Custom Component Example  Here is a custom slider component that can be used for adjusting image saturation.    tsx import { defineConfig, wrapFieldsWithMeta } from 'tinacms'  //.. other fields {   label: "Image Saturation",   name: "saturation",   type: "number",   description: "My custom saturation field",   ui: {     parse: (val) =Number(val),      // wrapping our component in wrapFieldsWithMeta renders our label & description.     component: wrapFieldsWithMeta(({ field, input, meta }) ={       return (         <div          <input             name="saturation"             id="saturation"             type="range"             min="0"             max="10"             step=".1"             // This will pass along props.input.onChange to set our form values as this input changes.             {...input}           /          <br /          Value: {input.value}         </div      )     })   } }   Note: in this example, parse is also needed. Read more about parse.  
< im the input Using pre-built components
< 
< Tina also provides a variety of pre-built components. To specify these, the `ui.component` property should be configured with the string name of the registered field plugin.
< 
< Below is a list of default fields.
< 
< #
< im the output Using pre-built components  Tina also provides a variety of pre-built components. To specify these, the ui.component property should be configured with the string name of the registered field plugin.  Below is a list of default fields.  #
< im the input Default Field Plugins
< 
< - [text](/docs/reference/toolkit/fields/text/)
< - [textarea](/docs/reference/toolkit/fields/textarea/)
< - [number](/docs/reference/toolkit/fields/number/)
< - [image](/docs/reference/toolkit/fields/image/)
< - [color](/docs/reference/toolkit/fields/color/)
< - [toggle](/docs/reference/toolkit/fields/toggle/)
< - [radio-group](/docs/reference/toolkit/fields/radio-group/)
< - [select](/docs/reference/toolkit/fields/select/)
< - [tags](/docs/reference/toolkit/fields/tags/)
< - [list](/docs/reference/toolkit/fields/list/)
< - [group](/docs/reference/toolkit/fields/group/)
< - [group-list](/docs/reference/toolkit/fields/group-list/)
< - [blocks](/docs/reference/toolkit/fields/blocks/)
< - [date](/docs/reference/toolkit/fields/date/)
< 
< Tina also supports some add-on field plugins. These need to be imported and registered from separate packages:
< 
< - [markdown](/docs/reference/toolkit/fields/markdown/)
< - [html](/docs/reference/toolkit/fields/html/)
< 
< #
< im the output Default Field Plugins  - text - textarea - number - image - color - toggle - radio-group - select - tags - list - group - group-list - blocks - date  Tina also supports some add-on field plugins. These need to be imported and registered from separate packages:  - markdown - html  #
< im the input Configuring a field plugin
< 
< Each field has a unique set of properties that can be configured within the schema.
< 
< For example, if you take a look at the color field plugin's definition, it takes a `colorFormat` property. We can configure that in our schema like so:
< 
< ```ts
< // ...
<         {
<           type: 'string',
<           label: 'Background Color',
<           name: 'color',
<           ui: {
<             component: "color",
<             colorFormat: "rgb"
<           }
<         },
< // ...
< ```
< 
< 
< im the output Configuring a field plugin  Each field has a unique set of properties that can be configured within the schema.  For example, if you take a look at the color field plugin's definition, it takes a colorFormat property. We can configure that in our schema like so:  ts // ...         {           type: 'string',           label: 'Background Color',           name: 'color',           ui: {             component: "color",             colorFormat: "rgb"           }         }, // ...   
< im the input Video Tutorial
< 
< For those who prefer to learn from video, you can check out a snippet on "Customizing Components" from our ["TinaCMS Deep Dive"](https://www.youtube.com/watch?v=PcgnJDILv4w&list=PLPar4H9PHKVqoCwZy79PHr8-W_vA3lAOB&pp=iAQB) series.
< 
< <Youtube embedSrc="https://www.youtube.com/embed/amSRwAbgMR0?start=744" />
< 
< im the output Video Tutorial  For those who prefer to learn from video, you can check out a snippet on "Customizing Components" from our "TinaCMS Deep Dive" series.  <Youtube embedSrc="https://www.youtube.com/embed/amSRwAbgMR0?start=744" /
< im the input 
< If list is `true` the default label is often not very useful to editors.
< 
< ![list UI](https://res.cloudinary.com/forestry-demo/image/upload/v1649941182/tina-io/docs/extending-tina/Extending_Tina_No_List_Props.png)
< 
< The label used for list items can be customized using the `itemProps` function. The main use-case for this is to provide a custom label based on the data in the component.
< 
< For example, to use the `title` field as the label for this image gallery collection:
< 
< ```ts
3409,3493d3493
< im the input 
< 
< im the output  
< im the input Introduction
< 
< With Tina, your content is stored in Git along with your codebase. Tina provides a Content API in front of your repo-based content, so that you can interact with your files as if they're in a database.
< 
< You can:
< 
< - Query content for a given collection
< - Apply filters, sorting, pagination, etc
< - Query your content based on relational fields.
< 
< To interface with the API, you can use Tina's type-safe client for data-fetching, or manually write custom GraphQL queries and hit the API yourself.
< 
< 
< im the output Introduction  With Tina, your content is stored in Git along with your codebase. Tina provides a Content API in front of your repo-based content, so that you can interact with your files as if they're in a database.  You can:  - Query content for a given collection - Apply filters, sorting, pagination, etc - Query your content based on relational fields.  To interface with the API, you can use Tina's type-safe client for data-fetching, or manually write custom GraphQL queries and hit the API yourself.  
< im the input Making requests with the Tina Client
< 
< The Tina client is the easiest way to fetch your site's content. The client can be configured the `tina/config.<js|ts>` in the `defineConfig` function.
< 
< > Note: token, clientId and branch are **not** used in [local-mode](/docs/tina-cloud/#local-mode). To setup these values for production see [this doc](/docs/tina-cloud/overview)
< 
< ```js
< // tina/config.{js,ts,tsx}
< export default defineConfig({
<   schema,
<   token: '***',
<   clientId: '***',
<   branch: 'main',
< })
< ```
< 
< When working locally, the client is built with the local url ([http://localhost:4001/graphql](http://localhost:4001/graphql)). When in [production mode](/docs/tina-cloud/#prod-mode), `clientId`, `branch` and `token` are used to query TinaCloud.
< 
< Tina client provides a type-safe query builder, that is auto-generated based on your site's schema:
< 
< ```js
< import { client } from '../[pathToTina]/tina/__generated__/client'
< 
< const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })
< 
< console.log(myPost.data.title)
< ```
< 
< The above `client.queries.post` query is not built-in to Tina's API. This is an example of a query based on _your_ defined schema, (where you have a "post" collection defined).
< 
< On a page that displays a list of posts, you can fetch the posts like so:
< 
< ```js
< const postsResponse = await client.queries.postConnection()
< const posts = postsResponse.data.postConnection.edges.map((post) => {
<   return { slug: post.node._sys.filename }
< })
< // This would return an array like: [ { slug: 'HelloWorld.md'}, /*...*/ ]
< ```
< 
< > For more information on manually writing queries for your specific schema, check out our ["Writing Custom Queries"](/docs/data-fetching/custom-queries/#writing-inline-queries) docs.
< 
< 
< im the output Making requests with the Tina Client  The Tina client is the easiest way to fetch your site's content. The client can be configured the tina/config.<js|tsin the defineConfig function.  Note: token, clientId and branch are not used in local-mode  js // tina/config.{js,ts,tsx} export default defineConfig({   schema,   token: '',   clientId: '',   branch: 'main', })   When working locally, the client is built with the local url (http://localhost:4001/graphql, clientId, branch and token are used to query TinaCloud.  Tina client provides a type-safe query builder, that is auto-generated based on your site's schema:  js import { client } from '../[pathToTina]/tina/generated/client'  const myPost = await client.queries.post({ relativePath: 'HelloWorld.md' })  console.log(myPost.data.title)   The above client.queries.post query is not built-in to Tina's API. This is an example of a query based on your defined schema, (where you have a "post" collection defined).  On a page that displays a list of posts, you can fetch the posts like so:  js const postsResponse = await client.queries.postConnection() const posts = postsResponse.data.postConnection.edges.map((post) ={   return { slug: post.node.sys.filename } }) // This would return an array like: [ { slug: 'HelloWorld.md'}, /.../ ]   For more information on manually writing queries for your specific schema, check out our "Writing Custom Queries" docs.  
< im the input The Local Filesystem-based Content API
< 
< When developing locally, it's often beneficial to talk to the content on your local file-system, rather than talk to the hosted content API. Tina provides a CLI tool that lets you run the Content API locally next to your site. This allows all of your content to be made available through the same expressive GraphQL API during development.
< 
< > If you setup Tina via `@tinacms/cli init`, or used one of our starters, this should be setup by default. (Read about the CLI [here](/docs/graphql/cli/.)
< 
< 
< im the output The Local Filesystem-based Content API  When developing locally, it's often beneficial to talk to the content on your local file-system, rather than talk to the hosted content API. Tina provides a CLI tool that lets you run the Content API locally next to your site. This allows all of your content to be made available through the same expressive GraphQL API during development.  If you setup Tina via @tinacms/cli init, or used one of our starters, this should be setup by default. (Read about the CLI here  
< im the input Video Tutorial
< 
< For those who prefer to learn from video, you can check out a snippet on "Data Fetching" from our ["TinaCMS Deep Dive"](https://www.youtube.com/watch?v=PcgnJDILv4w&list=PLPar4H9PHKVqoCwZy79PHr8-W_vA3lAOB&pp=iAQB) series.
< 
< <Youtube embedSrc="https://www.youtube.com/embed/PcgnJDILv4w?start=403&end=534" />
< 
< 
< im the output Video Tutorial  For those who prefer to learn from video, you can check out a snippet on "Data Fetching" from our "TinaCMS Deep Dive" series.  <Youtube embedSrc="https://www.youtube.com/embed/PcgnJDILv4w?start=403&end=534" / 
< im the input Summary
< 
< - Tina provides a GraphQL API for querying your git-based content.
< - Tina provides a client that allows you to make type-safe requests to the Content API.
< - The client's "queries" property is generated based on _your_ schema.
< - A local version of the Content API can be used for local development.
< 
< im the output Summary  - Tina provides a GraphQL API for querying your git-based content. - Tina provides a client that allows you to make type-safe requests to the Content API. - The client's "queries" property is generated based on your schema. - A local version of the Content API can be used for local development. 
9813a9814,10050
> 
> im the output  
> im the input Custom shortcode syntax
> 
> <WarningCallout body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our community channels or via the related [GitHub discussion](https://github.com/tinacms/tinacms/discussions/4794)." />
> 
> If you have some custom shortcode logic in your markdown, you can specify it in the `templates` property and Tina will handle it as if it were a `jsx` element:
> 
> The following snippet would throw an error while parsing since Tina doesn't know what to do with `{{}}`:
> 
> ```markdown
> {{ WarningCallout content="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our [community channels](/community/)!" }}
> ```
> 
> But you can tell Tina how to handle it with a `template`:
> 
> ```ts
> fields: [
>   {
>     type: 'rich-text',
>     name: 'body',
>     templates: [
>       {
>         name: 'WarningCallout',
>         label: 'WarningCallout',
>         match: {
>           start: '{{',
>           end: '}}',
>         },
>         fields: [
>           {
>             name: 'content',
>             label: 'Content',
>             type: 'string',
>             required: true,
>             ui: {
>               component: 'textarea',
>             },
>           },
>         ],
>       },
>     ],
>   },
> ]
> ```
> 
> #
> im the output Custom shortcode syntax  <WarningCallout body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our community channels or via the related GitHub discussion." / If you have some custom shortcode logic in your markdown, you can specify it in the templates property and Tina will handle it as if it were a jsx element:  The following snippet would throw an error while parsing since Tina doesn't know what to do with :  markdown    But you can tell Tina how to handle it with a template:  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'WarningCallout',         label: 'WarningCallout',         match: {           start: '{{',           end: '}}',         },         fields: [           {             name: 'content',             label: 'Content',             type: 'string',             required: true,             ui: {               component: 'textarea',             },           },         ],       },     ],   }, ]   #
> im the input Raw strings in shortcodes
> 
> Certain frameworks support shortcodes with Raw string values:
> 
> ```
> {{  myshortcode "This is some raw text" }}
> ```
> 
> This is supported in Tina with the special `_value` field.
> 
> ```ts
> fields: [
>   {
>     type: 'rich-text',
>     name: 'body',
>     templates: [
>       {
>         name: 'myshortcode',
>         label: 'myshortcode',
>         match: {
>           start: '{{',
>           end: '}}',
>         },
>         fields: [
>           {
>             name: '_value',
>             label: 'value',
>             type: 'string',
>             required: true,
>           },
>         ],
>       },
>     ],
>   },
> ]
> ```
> 
> #
> im the output Raw strings in shortcodes  Certain frameworks support shortcodes with Raw string values:      This is supported in Tina with the special value field.  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'myshortcode',         label: 'myshortcode',         match: {           start: '{{',           end: '}}',         },         fields: [           {             name: 'value',             label: 'value',             type: 'string',             required: true,           },         ],       },     ],   }, ]   #
> im the input Nesting content in a shortcode
> 
> Shortcodes can provide a `children` field, which allows content to be nested within a shortcode.
> 
> ```md
> {{% shortcode %}}
> What up!
> {{% /shortcode %}}
> ```
> 
> Your field template definition would look something like:
> 
> ```javascript
> {
>   name: "pull_quote2",
>   label: "pull_quote2",
>   match: {
>     name: "shortcode",
>     start: "{{%",
>     end: "%}}"
>   },
>   fields: [
>     {
>       name: "children",
>       type: "rich-text"
>     }
>   ]
> }
> ```
> 
> > Note: the children type currently needs to be of type: \`rich-text\`.
> 
> #
> im the output Nesting content in a shortcode  Shortcodes can provide a children field, which allows content to be nested within a shortcode.  md  What up!    Your field template definition would look something like:  javascript {   name: "pullquote2",   label: "pullquote2",   match: {     name: "shortcode",     start: "{{%",     end: "%}}"   },   fields: [     {       name: "children",       type: "rich-text"     }   ] }   Note: the children type currently needs to be of type: \rich-text\.  #
> im the input Using shortcode names with dashes
> 
> Sometimes your shortcode will contain characters that aren't supported in Tina's content modelling
> 
> ```md
> {{ my-shortcode }}
> ```
> 
> You can supply a `name` on the `match` object to handle this.
> 
> ```ts
> fields: [
>   {
>     type: 'rich-text',
>     name: 'body',
>     templates: [
>       {
>         name: 'myshortcode',
>         label: 'myshortcode',
>         match: {
>           start: '{{',
>           end: '}}',
>           name: 'my-shortcode',
>         },
>         // ...
>       },
>     ],
>   },
> ]
> ```
> 
> 
> im the output Using shortcode names with dashes  Sometimes your shortcode will contain characters that aren't supported in Tina's content modelling  md    You can supply a name on the match object to handle this.  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'myshortcode',         label: 'myshortcode',         match: {           start: '{{',           end: '}}',           name: 'my-shortcode',         },         // ...       },     ],   }, ]   
> im the input Other notes
> 
> #
> im the output Other notes  #
> im the input Full Spec
> 
> The full Tina MDX spec can be found [here](https://github.com/tinacms/tinacms/blob/main/packages/%40tinacms/mdx/spec.md "TinaCMS MDX Spec")
> 
> #
> im the output Full Spec  The full Tina MDX spec can be found here  #
> im the input Default values
> 
> If setting a default value for a rich-text field, you must provide the document AST. See [example here](/docs/schema/#default-value-for-rich-text)
> 
> #
> im the output Default values  If setting a default value for a rich-text field, you must provide the document AST. See example here  #
> im the input Shortcode in the CMS
> 
> The shortcode appears in the CMS as any other custom markdown embed. To inspect the shortcode in the CMS, use the raw markdown option in the editor.
> 
> ![](https://res.cloudinary.com/forestry-demo/image/upload/v1726549409/tina-io/docs/2024-09-17_15-01-58_lqfbf9.png)
> 
> im the output Shortcode in the CMS  The shortcode appears in the CMS as any other custom markdown embed. To inspect the shortcode in the CMS, use the raw markdown option in the editor.   
> im the input 
> 
> im the output  
> im the input Usage
> 
> <WarningCallout
>   body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat or through one of our community channels. 
> 
>   For further development work on Markdown Tables, engage with the related [GitHub issue](https://github.com/tinacms/tinacms/discussions/4793) or [contribute](https://github.com/tinacms/tinacms)."
> />
> 
> Tables are supported through a custom template which is exported from `tinacms`. To use it, import it and provide it as a `template` for your `rich-text` field:
> 
> ```ts
> import { tinaTableTemplate } from 'tinacms'
> 
> {
>   type: 'rich-text',
>   label: 'Body',
>   name: '_body',
>   templates: [
>     tinaTableTemplate,
>   ]
> }
> ```
> 
> Render it with the `table` component in `<TinaMarkdown>`. Note that the table cell's `value` is a rich-text element so should be rendered with a nested `<TinaMarkdown>` component:
> 
> ```tsx
> const MyTable = props => <table>
>     {props.tableRows?.map((tableRow, i) => (
>       <tbody key={i}>
>         <tr>
>           {tableRow.tableCells?.map((tableCell, j) => (
>             <td key={j}>
>               <TinaMarkdown content={tableCell.value} />
>             </td>
>           ))}
>         </tr>
>       </tbody>
>     ))}
>   </table>
> 
> <TinaMarkdown content={data.page._body} components={{ table: (props) => <MyTable {...props} /> }} />
> ```
> 
> 
> im the output Usage  <WarningCallout   body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat or through one of our community channels.     For further development work on Markdown Tables, engage with the related GitHub issue." / Tables are supported through a custom template which is exported from tinacms. To use it, import it and provide it as a template for your rich-text field:  ts import { tinaTableTemplate } from 'tinacms'  {   type: 'rich-text',   label: 'Body',   name: 'body',   templates: [     tinaTableTemplate,   ] }   Render it with the table component in <TinaMarkdown. Note that the table cell's value is a rich-text element so should be rendered with a nested <TinaMarkdowncomponent:  tsx const MyTable = props =<table    {props.tableRows?.map((tableRow, i) =(       <tbody key={i}        <tr          {tableRow.tableCells?.map((tableCell, j) =(             <td key={j}              <TinaMarkdown content={tableCell.value} /            </td          ))}         </tr      </tbody    ))}   </table <TinaMarkdown content={data.page.body} components= /  
> im the input Showcase
> 
> ![](https://res.cloudinary.com/forestry-demo/image/upload/v1726549733/tina-io/docs/2024-09-13_15-59-11_1_y2elbn.gif)
> 
> 
> im the output Showcase    
> im the input Known Issues
> 
> The table can only be saved if added with cell data immediately after creation, before leaving the CMS subwindow. This issue only occurs on initial creation of the table.
> 
> im the output Known Issues  The table can only be saved if added with cell data immediately after creation, before leaving the CMS subwindow. This issue only occurs on initial creation of the table. 
> im the input 
10154c10391
< im the input Custom shortcode syntax
---
> im the input Introduction
10156c10393
< <WarningCallout body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our community channels or via the related [GitHub discussion](https://github.com/tinacms/tinacms/discussions/4794)." />
---
> This doc will guide you through setting up our pre-configured self-hosted example repository. This implementation uses:
10158,10160c10395,10397
< If you have some custom shortcode logic in your markdown, you can specify it in the `templates` property and Tina will handle it as if it were a `jsx` element:
< 
< The following snippet would throw an error while parsing since Tina doesn't know what to do with `{{}}`:
---
> - [NextJS](https://nextjs.org/)
> - [Vercel](/docs/reference/self-hosted/database-adapters/vercel-kv) KV for the [database adapter](/docs/reference/self-hosted/database-adapters/overview)
> - [NextAuth](/docs/reference/self-hosted/auth-provider/authjs) for its [auth provider](/docs/reference/self-hosted/auth-providers/overview)
10162,10164d10398
< ```markdown
< {{ WarningCallout content="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our [community channels](/community/)!" }}
< ```
10166c10400,10401
< But you can tell Tina how to handle it with a `template`:
---
> im the output Introduction  This doc will guide you through setting up our pre-configured self-hosted example repository. This implementation uses:  - NextJS - Vercel - NextAuth  
> im the input Deploy The Starter Template
10168,10196c10403,10405
< ```ts
< fields: [
<   {
<     type: 'rich-text',
<     name: 'body',
<     templates: [
<       {
<         name: 'WarningCallout',
<         label: 'WarningCallout',
<         match: {
<           start: '{{',
<           end: '}}',
<         },
<         fields: [
<           {
<             name: 'content',
<             label: 'Content',
<             type: 'string',
<             required: true,
<             ui: {
<               component: 'textarea',
<             },
<           },
<         ],
<       },
<     ],
<   },
< ]
< ```
---
> <Youtube embedSrc="https://www.youtube.com/embed/DAJpnjkLBbM" />
> 
> You can deploy the [self-hosted starter](https://github.com/tinacms/tina-self-hosted-demo) using [our preconfigured Vercel template](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Ftinacms%2Ftina-self-hosted-demo%2Ftree%2Fmain&env=GITHUB_PERSONAL_ACCESS_TOKEN,NEXTAUTH_SECRET&envDescription=NEXTAUTH_SECRET%20can%20be%20generated%20with%3A%20%60openssl%20rand%20-hex%2016%60%20and%20the%20github%20token%20can%20be%20created%20here%3A%20https%3A%2F%2Fgithub.com%2Fsettings%2Fpersonal-access-tokens%2Fnew&stores=%5B%7B%22type%22%3A%22kv%22%7D%5D):
10198,10200c10407
< #
< im the output Custom shortcode syntax  <WarningCallout body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat, or through one of our community channels or via the related GitHub discussion." / If you have some custom shortcode logic in your markdown, you can specify it in the templates property and Tina will handle it as if it were a jsx element:  The following snippet would throw an error while parsing since Tina doesn't know what to do with :  markdown    But you can tell Tina how to handle it with a template:  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'WarningCallout',         label: 'WarningCallout',         match: {           start: '{{',           end: '}}',         },         fields: [           {             name: 'content',             label: 'Content',             type: 'string',             required: true,             ui: {               component: 'textarea',             },           },         ],       },     ],   }, ]   #
< im the input Raw strings in shortcodes
---
> This will:
10202c10409,10411
< Certain frameworks support shortcodes with Raw string values:
---
> - Create a copy of the self-hosted starter [repository](https://github.com/tinacms/tina-self-hosted-demo) in your GitHub account
> - Create a new Vercel project with the starter code
> - Create a new Vercel KV store for the project
10204,10206c10413,10415
< ```
< {{  myshortcode "This is some raw text" }}
< ```
---
> #
> im the output Deploy The Starter Template  <Youtube embedSrc="https://www.youtube.com/embed/DAJpnjkLBbM" / You can deploy the self-hosted starter:  This will:  - Create a copy of the self-hosted starter repository in your GitHub account - Create a new Vercel project with the starter code - Create a new Vercel KV store for the project  #
> im the input Setup Vercel KV Store
10208c10417
< This is supported in Tina with the special `_value` field.
---
> In the initial Vercel project setup, you will be prompted to set up the Vercel KV store. Use the default `KV_` environment variables prefix.
10210,10236d10418
< ```ts
< fields: [
<   {
<     type: 'rich-text',
<     name: 'body',
<     templates: [
<       {
<         name: 'myshortcode',
<         label: 'myshortcode',
<         match: {
<           start: '{{',
<           end: '}}',
<         },
<         fields: [
<           {
<             name: '_value',
<             label: 'value',
<             type: 'string',
<             required: true,
<           },
<         ],
<       },
<     ],
<   },
< ]
< ```
< 
10238,10239c10420,10421
< im the output Raw strings in shortcodes  Certain frameworks support shortcodes with Raw string values:      This is supported in Tina with the special value field.  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'myshortcode',         label: 'myshortcode',         match: {           start: '{{',           end: '}}',         },         fields: [           {             name: 'value',             label: 'value',             type: 'string',             required: true,           },         ],       },     ],   }, ]   #
< im the input Nesting content in a shortcode
---
> im the output Setup Vercel KV Store  In the initial Vercel project setup, you will be prompted to set up the Vercel KV store. Use the default KV environment variables prefix.  #
> im the input Setup Environment Variables
10241c10423
< Shortcodes can provide a `children` field, which allows content to be nested within a shortcode.
---
> You will be prompted to enter values for the following environment variables:
10243,10247c10425,10427
< ```md
< {{% shortcode %}}
< What up!
< {{% /shortcode %}}
< ```
---
> ##
> im the output Setup Environment Variables  You will be prompted to enter values for the following environment variables:  ##
> im the input `GITHUB_PERSONAL_ACCESS_TOKEN`
10249c10429
< Your field template definition would look something like:
---
> A GitHub personal access token can be generated in your [GitHub developer settings](https://github.com/settings/personal-access-tokens/new). Make sure to assign it `repo` access to the new repository with Read/Write access to Contents.
10251,10267c10431
< ```javascript
< {
<   name: "pull_quote2",
<   label: "pull_quote2",
<   match: {
<     name: "shortcode",
<     start: "{{%",
<     end: "%}}"
<   },
<   fields: [
<     {
<       name: "children",
<       type: "rich-text"
<     }
<   ]
< }
< ```
---
> You may want to change the expiry date to longer than 30 days (max is 1 year).
10269c10433
< > Note: the children type currently needs to be of type: \`rich-text\`.
---
> ![Github Auth Settings](https://res.cloudinary.com/forestry-demo/image/upload/c_thumb,w_1000,g_face/v1699036547/tina-io/docs/self-hosted/personal-access-token.png)
10271,10273c10435,10437
< #
< im the output Nesting content in a shortcode  Shortcodes can provide a children field, which allows content to be nested within a shortcode.  md  What up!    Your field template definition would look something like:  javascript {   name: "pullquote2",   label: "pullquote2",   match: {     name: "shortcode",     start: "{{%",     end: "%}}"   },   fields: [     {       name: "children",       type: "rich-text"     }   ] }   Note: the children type currently needs to be of type: \rich-text\.  #
< im the input Using shortcode names with dashes
---
> ##
> im the output GITHUBPERSONALACCESSTOKEN  A GitHub personal access token can be generated in your GitHub developer settings. Make sure to assign it repo access to the new repository with Read/Write access to Contents.  You may want to change the expiry date to longer than 30 days (max is 1 year).    ##
> im the input `NEXTAUTH_SECRET`
10275c10439
< Sometimes your shortcode will contain characters that aren't supported in Tina's content modelling
---
> Random string used by NextAuth.js for JWT encryption.
10277,10279c10441
< ```md
< {{ my-shortcode }}
< ```
---
> Can be generated with the following command:
10281,10301c10443,10444
< You can supply a `name` on the `match` object to handle this.
< 
< ```ts
< fields: [
<   {
<     type: 'rich-text',
<     name: 'body',
<     templates: [
<       {
<         name: 'myshortcode',
<         label: 'myshortcode',
<         match: {
<           start: '{{',
<           end: '}}',
<           name: 'my-shortcode',
<         },
<         // ...
<       },
<     ],
<   },
< ]
---
> ```shell
> openssl rand -hex 16
10304,10307d10446
< 
< im the output Using shortcode names with dashes  Sometimes your shortcode will contain characters that aren't supported in Tina's content modelling  md    You can supply a name on the match object to handle this.  ts fields: [   {     type: 'rich-text',     name: 'body',     templates: [       {         name: 'myshortcode',         label: 'myshortcode',         match: {           start: '{{',           end: '}}',           name: 'my-shortcode',         },         // ...       },     ],   }, ]   
< im the input Other notes
< 
10309,10310c10448,10449
< im the output Other notes  #
< im the input Full Spec
---
> im the output NEXTAUTHSECRET  Random string used by NextAuth.js for JWT encryption.  Can be generated with the following command:  shell openssl rand -hex 16   #
> im the input Test Deployment
10312c10451
< The full Tina MDX spec can be found [here](https://github.com/tinacms/tinacms/blob/main/packages/%40tinacms/mdx/spec.md "TinaCMS MDX Spec")
---
> At this point you should be able to see your deployed starter site. If you add `/admin` to the URL, you should be prompted to login. You can login with the **default username** of `tinauser` and **password** of `tinarocks`. Once logged in you will be prompted to change your password.
10314,10316c10453
< #
< im the output Full Spec  The full Tina MDX spec can be found here  #
< im the input Default values
---
> ![TinaCMS username and password](https://res.cloudinary.com/forestry-demo/image/upload/c_thumb,w_600,g_face/v1699559718/tina-io/docs/self-hosted/tina-login-screen2.png)
10318d10454
< If setting a default value for a rich-text field, you must provide the document AST. See [example here](/docs/schema/#default-value-for-rich-text)
10320,10322c10456,10457
< #
< im the output Default values  If setting a default value for a rich-text field, you must provide the document AST. See example here  #
< im the input Shortcode in the CMS
---
> im the output Test Deployment  At this point you should be able to see your deployed starter site. If you add /admin to the URL, you should be prompted to login. You can login with the default username of tinauser and password of tinarocks. Once logged in you will be prompted to change your password.    
> im the input Adding Additional Users
10324c10459
< The shortcode appears in the CMS as any other custom markdown embed. To inspect the shortcode in the CMS, use the raw markdown option in the editor.
---
> Check out the [User management docs](/docs/self-hosted/user-management/) for information on how to add additional users.
10326c10461
< ![](https://res.cloudinary.com/forestry-demo/image/upload/v1726549409/tina-io/docs/2024-09-17_15-01-58_lqfbf9.png)
---
> > Note: when you're testing TinaCMS locally, you don't need to be logged in to access the CMS."
10328,10329d10462
< im the output Shortcode in the CMS  The shortcode appears in the CMS as any other custom markdown embed. To inspect the shortcode in the CMS, use the raw markdown option in the editor.   
< im the input 
10331,10332c10464,10465
< im the output  
< im the input Usage
---
> im the output Adding Additional Users  Check out the User management docs for information on how to add additional users.  Note: when you're testing TinaCMS locally, you don't need to be logged in to access the CMS."  
> im the input Local Development
10334,10335c10467,10469
< <WarningCallout
<   body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat or through one of our community channels. 
---
> #
> im the output Local Development  #
> im the input Clone the Repository
10337,10338c10471
<   For further development work on Markdown Tables, engage with the related [GitHub issue](https://github.com/tinacms/tinacms/discussions/4793) or [contribute](https://github.com/tinacms/tinacms)."
< />
---
> (Replace the URL with your newly forked repo)
10340c10473,10475
< Tables are supported through a custom template which is exported from `tinacms`. To use it, import it and provide it as a `template` for your `rich-text` field:
---
> ```shell
> git clone <YourGitUrl>
> ```
10342,10343c10477
< ```ts
< import { tinaTableTemplate } from 'tinacms'
---
> Install the project's dependencies:
10345,10352c10479,10480
< {
<   type: 'rich-text',
<   label: 'Body',
<   name: '_body',
<   templates: [
<     tinaTableTemplate,
<   ]
< }
---
> ```shell
> yarn install
10355c10483,10485
< Render it with the `table` component in `<TinaMarkdown>`. Note that the table cell's `value` is a rich-text element so should be rendered with a nested `<TinaMarkdown>` component:
---
> #
> im the output Clone the Repository  (Replace the URL with your newly forked repo)  shell git clone <YourGitUrl  Install the project's dependencies:  shell yarn install   #
> im the input Configure the Development Environment
10357,10370c10487
< ```tsx
< const MyTable = props => <table>
<     {props.tableRows?.map((tableRow, i) => (
<       <tbody key={i}>
<         <tr>
<           {tableRow.tableCells?.map((tableCell, j) => (
<             <td key={j}>
<               <TinaMarkdown content={tableCell.value} />
<             </td>
<           ))}
<         </tr>
<       </tbody>
<     ))}
<   </table>
---
> Setup the .env file:
10372c10489,10490
< <TinaMarkdown content={data.page._body} components={{ table: (props) => <MyTable {...props} /> }} />
---
> ```shell
> cp .env.example .env
10374a10493,10494
> Use the same environment variables locally that you setup with the Vercel project earlier.
> You will also need to add some environment variables that are applied automatically in Vercel for your [Vercel KV Store](https://vercel.com/dashboard/stores)
10376,10377c10496,10498
< im the output Usage  <WarningCallout   body="This is an experimental feature, and the API is subject to change. Have any thoughts? Let us know in the chat or through one of our community channels.     For further development work on Markdown Tables, engage with the related GitHub issue." / Tables are supported through a custom template which is exported from tinacms. To use it, import it and provide it as a template for your rich-text field:  ts import { tinaTableTemplate } from 'tinacms'  {   type: 'rich-text',   label: 'Body',   name: 'body',   templates: [     tinaTableTemplate,   ] }   Render it with the table component in <TinaMarkdown. Note that the table cell's value is a rich-text element so should be rendered with a nested <TinaMarkdowncomponent:  tsx const MyTable = props =<table    {props.tableRows?.map((tableRow, i) =(       <tbody key={i}        <tr          {tableRow.tableCells?.map((tableCell, j) =(             <td key={j}              <TinaMarkdown content={tableCell.value} /            </td          ))}         </tr      </tbody    ))}   </table <TinaMarkdown content={data.page.body} components= /  
< im the input Showcase
---
> ```env
> # Github credentials for onPut and onDelete
> GITHUB_PERSONAL_ACCESS_TOKEN=
10379c10500,10503
< ![](https://res.cloudinary.com/forestry-demo/image/upload/v1726549733/tina-io/docs/2024-09-13_15-59-11_1_y2elbn.gif)
---
> # Required when building locally
> GITHUB_OWNER=
> GITHUB_REPO=
> GITHUB_BRANCH=
10380a10505,10506
> # Used by NextAuth.js to encrypt JWT
> NEXTAUTH_SECRET=changeme
10382,10383c10508,10511
< im the output Showcase    
< im the input Known Issues
---
> # Used by Vercel KV (Can be found in the vercel dashboard)
> KV_REST_API_URL=
> KV_REST_API_TOKEN=
> ```
10385c10513,10515
< The table can only be saved if added with cell data immediately after creation, before leaving the CMS subwindow. This issue only occurs on initial creation of the table.
---
> #
> im the output Configure the Development Environment  Setup the .env file:  shell cp .env.example .env   Use the same environment variables locally that you setup with the Vercel project earlier. You will also need to add some environment variables that are applied automatically in Vercel for your Vercel KV Store  env Github credentials for onPut and onDelete GITHUBPERSONALACCESSTOKEN=  Required when building locally GITHUBOWNER= GITHUBREPO= GITHUBBRANCH=  Used by NextAuth.js to encrypt JWT NEXTAUTHSECRET=changeme  Used by Vercel KV (Can be found in the vercel dashboard) KVRESTAPIURL= KVRESTAPITOKEN=   #
> im the input Run the Project Locally
10387c10517,10523
< im the output Known Issues  The table can only be saved if added with cell data immediately after creation, before leaving the CMS subwindow. This issue only occurs on initial creation of the table. 
---
> ```shell
> yarn dev
> ```
> 
> You will be able to view your starter on [http://localhost:3000](http://localhost:3000). To edit content with TinaCMS go to [http://localhost:3000/admin](http://localhost:3000/admin)
> 
> im the output Run the Project Locally  shell yarn dev   You will be able to view your starter on http://localhost:3000 
11711,11846d11846
< im the input 
< 
< im the output  
< im the input Introduction
< 
< This doc will guide you through setting up our pre-configured self-hosted example repository. This implementation uses:
< 
< - [NextJS](https://nextjs.org/)
< - [Vercel](/docs/reference/self-hosted/database-adapters/vercel-kv) KV for the [database adapter](/docs/reference/self-hosted/database-adapters/overview)
< - [NextAuth](/docs/reference/self-hosted/auth-provider/authjs) for its [auth provider](/docs/reference/self-hosted/auth-providers/overview)
< 
< 
< im the output Introduction  This doc will guide you through setting up our pre-configured self-hosted example repository. This implementation uses:  - NextJS - Vercel - NextAuth  
< im the input Deploy The Starter Template
< 
< <Youtube embedSrc="https://www.youtube.com/embed/DAJpnjkLBbM" />
< 
< You can deploy the [self-hosted starter](https://github.com/tinacms/tina-self-hosted-demo) using [our preconfigured Vercel template](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Ftinacms%2Ftina-self-hosted-demo%2Ftree%2Fmain&env=GITHUB_PERSONAL_ACCESS_TOKEN,NEXTAUTH_SECRET&envDescription=NEXTAUTH_SECRET%20can%20be%20generated%20with%3A%20%60openssl%20rand%20-hex%2016%60%20and%20the%20github%20token%20can%20be%20created%20here%3A%20https%3A%2F%2Fgithub.com%2Fsettings%2Fpersonal-access-tokens%2Fnew&stores=%5B%7B%22type%22%3A%22kv%22%7D%5D):
< 
< This will:
< 
< - Create a copy of the self-hosted starter [repository](https://github.com/tinacms/tina-self-hosted-demo) in your GitHub account
< - Create a new Vercel project with the starter code
< - Create a new Vercel KV store for the project
< 
< #
< im the output Deploy The Starter Template  <Youtube embedSrc="https://www.youtube.com/embed/DAJpnjkLBbM" / You can deploy the self-hosted starter:  This will:  - Create a copy of the self-hosted starter repository in your GitHub account - Create a new Vercel project with the starter code - Create a new Vercel KV store for the project  #
< im the input Setup Vercel KV Store
< 
< In the initial Vercel project setup, you will be prompted to set up the Vercel KV store. Use the default `KV_` environment variables prefix.
< 
< #
< im the output Setup Vercel KV Store  In the initial Vercel project setup, you will be prompted to set up the Vercel KV store. Use the default KV environment variables prefix.  #
< im the input Setup Environment Variables
< 
< You will be prompted to enter values for the following environment variables:
< 
< ##
< im the output Setup Environment Variables  You will be prompted to enter values for the following environment variables:  ##
< im the input `GITHUB_PERSONAL_ACCESS_TOKEN`
< 
< A GitHub personal access token can be generated in your [GitHub developer settings](https://github.com/settings/personal-access-tokens/new). Make sure to assign it `repo` access to the new repository with Read/Write access to Contents.
< 
< You may want to change the expiry date to longer than 30 days (max is 1 year).
< 
< ![Github Auth Settings](https://res.cloudinary.com/forestry-demo/image/upload/c_thumb,w_1000,g_face/v1699036547/tina-io/docs/self-hosted/personal-access-token.png)
< 
< ##
< im the output GITHUBPERSONALACCESSTOKEN  A GitHub personal access token can be generated in your GitHub developer settings. Make sure to assign it repo access to the new repository with Read/Write access to Contents.  You may want to change the expiry date to longer than 30 days (max is 1 year).    ##
< im the input `NEXTAUTH_SECRET`
< 
< Random string used by NextAuth.js for JWT encryption.
< 
< Can be generated with the following command:
< 
< ```shell
< openssl rand -hex 16
< ```
< 
< #
< im the output NEXTAUTHSECRET  Random string used by NextAuth.js for JWT encryption.  Can be generated with the following command:  shell openssl rand -hex 16   #
< im the input Test Deployment
< 
< At this point you should be able to see your deployed starter site. If you add `/admin` to the URL, you should be prompted to login. You can login with the **default username** of `tinauser` and **password** of `tinarocks`. Once logged in you will be prompted to change your password.
< 
< ![TinaCMS username and password](https://res.cloudinary.com/forestry-demo/image/upload/c_thumb,w_600,g_face/v1699559718/tina-io/docs/self-hosted/tina-login-screen2.png)
< 
< 
< im the output Test Deployment  At this point you should be able to see your deployed starter site. If you add /admin to the URL, you should be prompted to login. You can login with the default username of tinauser and password of tinarocks. Once logged in you will be prompted to change your password.    
< im the input Adding Additional Users
< 
< Check out the [User management docs](/docs/self-hosted/user-management/) for information on how to add additional users.
< 
< > Note: when you're testing TinaCMS locally, you don't need to be logged in to access the CMS."
< 
< 
< im the output Adding Additional Users  Check out the User management docs for information on how to add additional users.  Note: when you're testing TinaCMS locally, you don't need to be logged in to access the CMS."  
< im the input Local Development
< 
< #
< im the output Local Development  #
< im the input Clone the Repository
< 
< (Replace the URL with your newly forked repo)
< 
< ```shell
< git clone <YourGitUrl>
< ```
< 
< Install the project's dependencies:
< 
< ```shell
< yarn install
< ```
< 
< #
< im the output Clone the Repository  (Replace the URL with your newly forked repo)  shell git clone <YourGitUrl  Install the project's dependencies:  shell yarn install   #
< im the input Configure the Development Environment
< 
< Setup the .env file:
< 
< ```shell
< cp .env.example .env
< ```
< 
< Use the same environment variables locally that you setup with the Vercel project earlier.
< You will also need to add some environment variables that are applied automatically in Vercel for your [Vercel KV Store](https://vercel.com/dashboard/stores)
< 
< ```env
< # Github credentials for onPut and onDelete
< GITHUB_PERSONAL_ACCESS_TOKEN=
< 
< # Required when building locally
< GITHUB_OWNER=
< GITHUB_REPO=
< GITHUB_BRANCH=
< 
< # Used by NextAuth.js to encrypt JWT
< NEXTAUTH_SECRET=changeme
< 
< # Used by Vercel KV (Can be found in the vercel dashboard)
< KV_REST_API_URL=
< KV_REST_API_TOKEN=
< ```
< 
< #
< im the output Configure the Development Environment  Setup the .env file:  shell cp .env.example .env   Use the same environment variables locally that you setup with the Vercel project earlier. You will also need to add some environment variables that are applied automatically in Vercel for your Vercel KV Store  env Github credentials for onPut and onDelete GITHUBPERSONALACCESSTOKEN=  Required when building locally GITHUBOWNER= GITHUBREPO= GITHUBBRANCH=  Used by NextAuth.js to encrypt JWT NEXTAUTHSECRET=changeme  Used by Vercel KV (Can be found in the vercel dashboard) KVRESTAPIURL= KVRESTAPITOKEN=   #
< im the input Run the Project Locally
< 
< ```shell
< yarn dev
< ```
< 
< You will be able to view your starter on [http://localhost:3000](http://localhost:3000). To edit content with TinaCMS go to [http://localhost:3000/admin](http://localhost:3000/admin)
< 
< im the output Run the Project Locally  shell yarn dev   You will be able to view your starter on http://localhost:3000 
11906,12664c11906
< This name is shown to your users when they log in to the project. Defaults to the repository name.
< 
< ##
< im the output Project Name  This name is shown to your users when they log in to the project. Defaults to the repository name.  ##
< im the input Site URL(s)
< 
< In these fields, enter both the local URL and the production site URL (if known). For security reasons, Tina will only work at these locations.
< 
< If you are developing locally, this value might be something like:
< 
< `http://localhost:3000`.
< 
< If TinaCloud is configured on your production site, this value might be something like:
< 
< `https://<YOUR-SITE-NAME.com>`
< 
< > For the Site URL, Only the URL origin is needed. There is no need to include the path to any specific pages.
< 
< ###
< im the output Site URL(s)  In these fields, enter both the local URL and the production site URL (if known). For security reasons, Tina will only work at these locations.  If you are developing locally, this value might be something like:  http://localhost:3000.  If TinaCloud is configured on your production site, this value might be something like:  https://<YOUR-SITE-NAME.com For the Site URL, Only the URL origin is needed. There is no need to include the path to any specific pages.  ###
< im the input Glob Patterns
< 
< Tina also supports Glob patterns for the Site URL. This can be useful if you want to allow editing on dynamic preview deployments.
< 
< E.g. on Vercel this may look like: `https://<VERCEL-PROJECT-NAME>-*-<VERCEL-ACCOUNT-OWNER>.vercel.app`
< 
< #
< im the output Glob Patterns  Tina also supports Glob patterns for the Site URL. This can be useful if you want to allow editing on dynamic preview deployments.  E.g. on Vercel this may look like: https://<VERCEL-PROJECT-NAME--<VERCEL-ACCOUNT-OWNER.vercel.app  #
< im the input 4. Using the project
< 
< Once your project is created, you will see it listed on your [Projects](https://app.tina.io/projects) page.
< 
< 
< im the output 4. Using the project  Once your project is created, you will see it listed on your Projects page.  
< im the input Administering the project
< 
< #
< im the output Administering the project  #
< im the input Overview
< 
< A project's Overview page gives you an important value: your project's unique **Client ID**. This value is used by TinaCloud to connect to your site's repository. You will need to use this value when setting up your site to use Tina.
< 
< #
< im the output Overview  A project's Overview page gives you an important value: your project's unique Client ID. This value is used by TinaCloud to connect to your site's repository. You will need to use this value when setting up your site to use Tina.  #
< im the input Configuration
< 
< After your project has been created, you can visit the Configuration page to update the Project Name, Site URL(s), or the GitHub repository
< 
< ##
< im the output Configuration  After your project has been created, you can visit the Configuration page to update the Project Name, Site URL(s), or the GitHub repository  ##
< im the input Changing the Repository
< 
< From the project configuration screen, click the "Change Repository" button. You will authorize Tina.io again and a list of repositories will be displayed. Selecting the new repository and click Save Project to update the repository.
< 
< ##
< im the output Changing the Repository  From the project configuration screen, click the "Change Repository" button. You will authorize Tina.io again and a list of repositories will be displayed. Selecting the new repository and click Save Project to update the repository.  ##
< im the input Advanced Settings
< 
< The Advanced Settings button is located in the Configuration tab of your project in TinaCloud.
< 
< ###
< im the output Advanced Settings  The Advanced Settings button is located in the Configuration tab of your project in TinaCloud.  ###
< im the input Path To Tina
< 
< If your \`tina\` directory is at the project root (as is for most site), this field can be left blank.\
< \
< If your GitHub repository uses a monorepo structure, the Path To Tina Config input can be used to specify the path to the
< `tina` directory in your repository. For example, if you have a project named `my-site`, and it is located in the
< `projects` directory of your repository, you would enter `projects/my-site` in this field and click Save Project to
< update the project.
< 
< ###
< im the output Path To Tina  If your \tina\ directory is at the project root (as is for most site), this field can be left blank.\ \ If your GitHub repository uses a monorepo structure, the Path To Tina Config input can be used to specify the path to the tina directory in your repository. For example, if you have a project named my-site, and it is located in the projects directory of your repository, you would enter projects/my-site in this field and click Save Project to update the project.  ###
< im the input Refresh Webhooks
< 
< In rare circumstances, the GitHub Webhook connecting your repository to TinaCloud may be disrupted. If the webhook does
< not execute, TinaCloud may become out of sync with your GitHub repository. Click the "Refresh Webhooks" button to restore them.
< 
< ###
< im the output Refresh Webhooks  In rare circumstances, the GitHub Webhook connecting your repository to TinaCloud may be disrupted. If the webhook does not execute, TinaCloud may become out of sync with your GitHub repository. Click the "Refresh Webhooks" button to restore them.  ###
< im the input Export Branch
< 
< Clicking this opens a modal dialog that allows you to push a new branch with the changes from an existing branch at a
< particular point in time. First select the branch where the changes are located under Source Branch. An export branch
< name is auto-generated from this selection, but can also be edited as desired as long as it doesn't conflict with an
< existing branch name. Next, select the point in time from which you want to push the changes, either
< 'Last Successful Push' or a custom date in the past. Once these selections are made, click the 'Export Branch' button. After
< a few minutes, the new branch will be available in your GitHub repository with any changes in TinaCloud. A pull request
< can then be created to merge the changes to your desired branch.
< 
< ###
< im the output Export Branch  Clicking this opens a modal dialog that allows you to push a new branch with the changes from an existing branch at a particular point in time. First select the branch where the changes are located under Source Branch. An export branch name is auto-generated from this selection, but can also be edited as desired as long as it doesn't conflict with an existing branch name. Next, select the point in time from which you want to push the changes, either 'Last Successful Push' or a custom date in the past. Once these selections are made, click the 'Export Branch' button. After a few minutes, the new branch will be available in your GitHub repository with any changes in TinaCloud. A pull request can then be created to merge the changes to your desired branch.  ###
< im the input Branch "Reindex"
< 
< Clicking "Reindex" on a branch will completely reset the cached copy of that branch in your GitHub repository and initiate a reindexing process. Any changes only present in the cached copy will be lost. Before reindexing, you should ensure that any changes have
< been successfully pushed to GitHub using the Export Branch feature.
< 
< #
< im the output Branch "Reindex"  Clicking "Reindex" on a branch will completely reset the cached copy of that branch in your GitHub repository and initiate a reindexing process. Any changes only present in the cached copy will be lost. Before reindexing, you should ensure that any changes have been successfully pushed to GitHub using the Export Branch feature.  #
< im the input API tokens
< 
< There are two types of tokens associated with projects in TinaCloud: Content (Read-only) and Search.
< 
< - Content tokens provide read-only access to your project's content.
< - Search tokens provide write access to the TinaCloud search API.
< 
< <WarningCallout body="Warning: API tokens should be considered sensitive and not be committed to your project repository. Content tokens allow clients read-only access to your repository content. Search tokens allow clients to update the TinaCloud hosted search index for your site. Please use environment variables for these in your Tina configuration." />
< 
< ##
< im the output API tokens  There are two types of tokens associated with projects in TinaCloud: Content (Read-only) and Search.  - Content tokens provide read-only access to your project's content. - Search tokens provide write access to the TinaCloud search API.  <WarningCallout body="Warning: API tokens should be considered sensitive and not be committed to your project repository. Content tokens allow clients read-only access to your repository content. Search tokens allow clients to update the TinaCloud hosted search index for your site. Please use environment variables for these in your Tina configuration." / ##
< im the input Generate tokens from the dashboard
< 
< By default, a new project will automatically generate both types of tokens with access to all branch types. If the project does not need to restrict access to specific branches, these tokens should be sufficient.
< 
< If additional tokens are needed, they can be generated by navigating to [TinaCloud](https://app.tina.io), clicking on the project you wish to add a token to, and clicking on the "Tokens" tab:
< ![TinaCloud token tab](https://res.cloudinary.com/forestry-demo/image/upload/v1686248278/tina-io/docs/tina-cloud/api_tokens_list_v1_mmjpsp.png)
< 
< Next, click "New Token" and fill out fields. The "Type" field selects the type of token being created. "Name" is used for identifying the token. "Git Branches" is the list of branches (separated by commas) that the token has access to.
< 
< ![Creating a new token in TinaCloud](https://res.cloudinary.com/forestry-demo/image/upload/v1686248661/tina-io/docs/tina-cloud/new_api_token_v1_lq1rfy.png)
< 
< These tokens will be used later when we connect the site's frontend to our project.
< 
< ##
< im the output Generate tokens from the dashboard  By default, a new project will automatically generate both types of tokens with access to all branch types. If the project does not need to restrict access to specific branches, these tokens should be sufficient.  If additional tokens are needed, they can be generated by navigating to TinaCloud, clicking on the project you wish to add a token to, and clicking on the "Tokens" tab:   Next, click "New Token" and fill out fields. The "Type" field selects the type of token being created. "Name" is used for identifying the token. "Git Branches" is the list of branches (separated by commas) that the token has access to.    These tokens will be used later when we connect the site's frontend to our project.  ##
< im the input Wild cards in branch names
< 
< Wild card matching is supported in branch names using '\*' to match anything. For example: `feat/*` will match both `feat/foo` and `feat/bar`. If only `*` is entered it will match any branch.
< 
< Wild card matching is useful for matching branches that have not been created yet and can be used for editorial workflows.
< 
< im the output Wild cards in branch names  Wild card matching is supported in branch names using '\' to match anything. For example: feat/ will match both feat/foo and feat/bar. If only  is entered it will match any branch.  Wild card matching is useful for matching branches that have not been created yet and can be used for editorial workflows. 
< im the input 
< Register for TinaCloud by navigating to the [registration page](https://app.tina.io/register).
< 
< You can register with either an existing GitHub account or create a new TinaCloud account:
< 
< ![tina-cloud-registration](/img/cloud-registration.png)
< 
< Once your account is verified, you will be able to login and access the dashboard.
< 
< im the output  Register for TinaCloud by navigating to the registration page.  You can register with either an existing GitHub account or create a new TinaCloud account:    Once your account is verified, you will be able to login and access the dashboard. 
< im the input 
< The **Collaborations** tab of a project allows users manage a project.
< 
< Project collaborators can have one of the following project-level roles:
< 
< - Editor
< - Admin
< 
< The following roles/permissions apply to "Project Admins" & "Project Editors":
< 
< | Actions                      | Project Admin | Project Editor |
< | ---------------------------- | ------------- | -------------- |
< | Edit Project Content         |             |              |
< | View Project Overview        |             |              |
< | Manage Project Configuration |             |              |
< | Manage Project Collaborators |             |              |
< 
< Both Admins and Editors are authorized to access the editing route on a Tina configured site. Both users can save content changes directly to a site's GitHub repository using TinaCMS.
< 
< > When a site is configured to use TinaCloud, an authorized user will be prompted for their TinaCloud credentials to access the editing route of the site.
< 
< im the output  The Collaborations tab of a project allows users manage a project.  Project collaborators can have one of the following project-level roles:  - Editor - Admin  The following roles/permissions apply to "Project Admins" & "Project Editors":  | Actions                      | Project Admin | Project Editor | |  |  |  | | Edit Project Content         |             |              | | View Project Overview        |             |              | | Manage Project Configuration |             |              | | Manage Project Collaborators |             |              |  Both Admins and Editors are authorized to access the editing route on a Tina configured site. Both users can save content changes directly to a site's GitHub repository using TinaCMS.  When a site is configured to use TinaCloud, an authorized user will be prompted for their TinaCloud credentials to access the editing route of the site. 
< im the input 
< GitHub Pages is a popular hosting option for static sites. GitHub Pages can be configured in **\<your-repo>** > **Settings** > **Pages**.
< 
< 
< im the output  GitHub Pages is a popular hosting option for static sites. GitHub Pages can be configured in \<your-repoSettings Pages.  
< im the input Build Configuration
< 
< GitHub Pages offers a few build options:
< 
< - GitHub Actions
< - Deploy from a branch
< 
< ![GitHub Actions](https://res.cloudinary.com/forestry-demo/image/upload/v1674654344/tina-io/docs/tina-cloud/Screen_Shot_2023-01-25_at_9.40.52_AM_fby9q2.png 'GitHub Actions')
< 
< We want to choose "**GitHub Actions**" so that we can control the build script, and make sure it's also building the TinaCMS admin
< 
< By clicking "Configure" on the action it's created for us, we can then tweak the build script to build tinacms along with our site.
< 
< Add the following step **before** your site's build step:
< 
< If you are using npm as your package name, you can use the following:
< 
< ```yml
< - name: Build TinaCMS
<   env:
<     TINA_PUBLIC_CLIENT_ID: ${{ secrets.TINA_PUBLIC_CLIENT_ID }}
<     TINA_TOKEN: ${{ secrets.TINA_TOKEN }}
<   run: npx tinacms build
< ```
< 
< or if you are using yarn:
< 
< ```yml
< - name: Build TinaCMS
<   env:
<     TINA_PUBLIC_CLIENT_ID: ${{ secrets.TINA_PUBLIC_CLIENT_ID }}
<     TINA_TOKEN: ${{ secrets.TINA_TOKEN }}
<   run: yarn build
<   # This assumes that your "build" script in your
<   # package.json is "tinacms build"
< ```
< 
< Your GitHub Action will look something like:
< 
< ![GitHub Action](https://res.cloudinary.com/forestry-demo/image/upload/v1675783496/tina-io/docs/tina-cloud/gh-config.png 'GitHub Action')
< 
< 
< im the output Build Configuration  GitHub Pages offers a few build options:  - GitHub Actions - Deploy from a branch    We want to choose "GitHub Actions" so that we can control the build script, and make sure it's also building the TinaCMS admin  By clicking "Configure" on the action it's created for us, we can then tweak the build script to build tinacms along with our site.  Add the following step before your site's build step:  If you are using npm as your package name, you can use the following:  yml - name: Build TinaCMS   env:     TINAPUBLICCLIENTID: $     TINATOKEN: $   run: npx tinacms build   or if you are using yarn:  yml - name: Build TinaCMS   env:     TINAPUBLICCLIENTID: $     TINATOKEN: $   run: yarn build   This assumes that your "build" script in your   package.json is "tinacms build"   Your GitHub Action will look something like:    
< im the input Common Issues
< 
< #
< im the output Common Issues  #
< im the input Common Issue: 'Missing script: "tinacms"'
< 
< This error might occur from the following reasons:
< 
< ##
< im the output Common Issue: 'Missing script: "tinacms"'  This error might occur from the following reasons:  ##
< im the input 1. tinacms dependencies not added to package.json.
< 
< Make sure that both the `tinacms` & `@tinacms/cli` dependencies are listed in your package.json.
< 
< ##
< im the output 1. tinacms dependencies not added to package.json.  Make sure that both the tinacms & @tinacms/cli dependencies are listed in your package.json.  ##
< im the input 2. Dependencies aren't being installed in CI.
< 
< If you are using npm make sure that `npm ci` is being run before the TinaCMS build command. If you are using yarn, make sure you are running `yarn install --frozen-lockfile` before running the build command.
< 
< ##
< im the output 2. Dependencies aren't being installed in CI.  If you are using npm make sure that npm ci is being run before the TinaCMS build command. If you are using yarn, make sure you are running yarn install --frozen-lockfile before running the build command.  ##
< im the input 3. Needing to define a 'tinacms' script.
< 
< If your CI is running something like `yarn tinacms build` instead of `npx tinacms build`, you'll need to add a custom script to your package.json:
< 
< ```json
<   "scripts": {
<     "tinacms": "tinacms",
<     // ...
< ```
< 
< #
< im the output 3. Needing to define a 'tinacms' script.  If your CI is running something like yarn tinacms build instead of npx tinacms build, you'll need to add a custom script to your package.json:  json   "scripts": {     "tinacms": "tinacms",     // ...   #
< im the input Common Issue: /admin is giving a 404
< 
< This can happen for a number of reasons but here are the most common reasons and fixes:
< 
< ##
< im the output Common Issue: /admin is giving a 404  This can happen for a number of reasons but here are the most common reasons and fixes:  ##
< im the input 1. Not providing a custom build workflow
< 
< If your site is deploying with GitHub Pages, it may be using GitHub's default build steps. In this case, TinaCMS won't be included in the build.
< 
< ![GitHub Pages configuration](https://res.cloudinary.com/forestry-demo/image/upload/v1683212636/gh-pages.png).
< 
< To fix this, you'll need to select the "GitHub Actions" source, and build the tinacms admin along with your site. You can see our doc above for help setting up this GitHub Action.
< 
< ##
< im the output 1. Not providing a custom build workflow  If your site is deploying with GitHub Pages, it may be using GitHub's default build steps. In this case, TinaCMS won't be included in the build.  .  To fix this, you'll need to select the "GitHub Actions" source, and build the tinacms admin along with your site. You can see our doc above for help setting up this GitHub Action.  ##
< im the input 2. 'tinacms build' is not running in CI
< 
< Check to make sure that the build command is running and not failing
< 
< > Note: If you are using [the github pages setup from hugo](https://gohugo.io/hosting-and-deployment/hosting-on-github/) you will need to make sure that a `package-lock.json` exists in the root of your repo.
< 
< #
< im the output 2. 'tinacms build' is not running in CI  Check to make sure that the build command is running and not failing  Note: If you are using the github pages setup from hugo you will need to make sure that a package-lock.json exists in the root of your repo.  #
< im the input Common Issue: The root URL is giving a 404
< 
< This is usually due to a missing entrypoint file for GitHub Pages.
< 
< To fix this, you'll need to create a file named `index.tsx` in the `./pages` directory. Your `index.tsx` should look something like this:
< 
< ```ts
< import Filename, { getStaticProps as FilenameStaticProps } from './[filename]';
< 
< const Index = Filename;
< 
< export const getStaticProps = async ({ params }) => {
<   return FilenameStaticProps({ params: { filename: 'home' } });
< }
< 
< export default Index;
< ```
< 
< 
< im the output Common Issue: The root URL is giving a 404  This is usually due to a missing entrypoint file for GitHub Pages.  To fix this, you'll need to create a file named index.tsx in the ./pages directory. Your index.tsx should look something like this:  ts import Filename, { getStaticProps as FilenameStaticProps } from './[filename]';  const Index = Filename;  export const getStaticProps = async ({ params }) ={   return FilenameStaticProps({ params: { filename: 'home' } }); }  export default Index;   
< im the input Environment variables
< 
< Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the GitHub Secrets for your project. The secrets we used in the code snippet above were `TINA_PUBLIC_CLIENT_ID` & `TINA_TOKEN`.
< 
< im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the GitHub Secrets for your project. The secrets we used in the code snippet above were TINAPUBLICCLIENTID & TINATOKEN. 
< im the input 
< 
< im the output  
< im the input Build Configuration
< 
< In Netlify, your build configuration can be updated at **Settings** > **Build & Deploy** > **Build Command**.
< 
< ![Netlify build config](https://res.cloudinary.com/forestry-demo/image/upload/v1674607585/Screen_Shot_2023-01-24_at_8.45.23_PM_gbqyqb.png 'Netlify build config')
< 
< > If your package.json has a "build" script like `tinacms build && <your-site-build-cmd>`, this likely doesn't need to be changed. If your Netlify config is not running a custom build script (e.g `next build`), you would have to change this to `tinacms build && next build`
< 
< > If your project has a `netlify.toml` with a build command set, that will take precedence over the above build command UI
< 
< 
< im the output Build Configuration  In Netlify, your build configuration can be updated at Settings Build & Deploy Build Command.    If your package.json has a "build" script like tinacms build && <your-site-build-cmd, this likely doesn't need to be changed. If your Netlify config is not running a custom build script (e.g next build), you would have to change this to tinacms build && next build  If your project has a netlify.toml with a build command set, that will take precedence over the above build command UI  
< im the input Environment variables
< 
< Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the Netlify UI for your project. You can learn more about environment variables [here](https://docs.netlify.com/environment-variables/overview/?_ga=2.128850127.213489666.1674607241-1149277376.1674150726 'netlify environment variables').
< 
< im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the Netlify UI for your project. You can learn more about environment variables here. 
< im the input 
< 
< im the output  
< im the input Build Configuration
< 
< In Vercel, your build configuration can be updated at **Settings** > **General** > **Build & Development Settings**.
< 
< ![Vercel Build Settings](https://res.cloudinary.com/forestry-demo/image/upload/v1674653527/tina-io/docs/tina-cloud/vercel-build-settings_vubza8.png 'Vercel Build Settings')
< 
< > If your package.json has a "build" script like `tinacms build && <your-site-build-cmd>`, this likely doesn't need to be changed. If your Vercel config is not running a custom build script (e.g `next build` instead of `npm run build`), you would have to change this to `tinacms build && next build`
< 
< 
< im the output Build Configuration  In Vercel, your build configuration can be updated at Settings General Build & Development Settings.    If your package.json has a "build" script like tinacms build && <your-site-build-cmd, this likely doesn't need to be changed. If your Vercel config is not running a custom build script (e.g next build instead of npm run build), you would have to change this to tinacms build && next build  
< im the input Environment variables
< 
< Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the Vercel "Environment Variables" tab for your project.
< 
< im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the Vercel "Environment Variables" tab for your project. 
< im the input 
< Tina automatically creates filters for collections defined in your schema.
< 
< To filter collection results, pass the `filter` argument to the `<collection>Connection` query, followed by any of the filter [operator types](/docs/graphql/queries/advanced/filter-documents/#operator-types) for the fields on your collection.
< 
< The `filter` object is a nested set of conditions where the keys correspond to the collection field and the value describes the condition.
< 
< Conditions can be either "binary" or "ternary". A binary condition is composed of a single operator and a single operand (i.e. `{"eq":"foo"}`). A ternary condition is composed of two operators and two operands (.i.e. `{"gt":0, "lte": 10}`).
< 
< 
< im the output  Tina automatically creates filters for collections defined in your schema.  To filter collection results, pass the filter argument to the <collectionConnection query, followed by any of the filter operator types for the fields on your collection.  The filter object is a nested set of conditions where the keys correspond to the collection field and the value describes the condition.  Conditions can be either "binary" or "ternary". A binary condition is composed of a single operator and a single operand (i.e. {"eq":"foo"}). A ternary condition is composed of two operators and two operands (.i.e. {"gt":0, "lte": 10}).  
< im the input Operator types
< 
< | Key        | Behavior                 | Type(s)                          |
< | :--------- | ------------------------ | -------------------------------- |
< | eq         | Equals                   | string, number, boolean          |
< | in         | One of                   | string\[], number\[], boolean\[] |
< | gt         | Greater than             | string, number                   |
< | gte        | Greater than or equal to | string, number                   |
< | lt         | Less than                | string, number                   |
< | lte        | Less than or equal to    | string, number                   |
< | startsWith | Starts with              | string                           |
< | after      | After                    | datetime                         |
< | before     | Before                   | datetime                         |
< 
< > Only `gt`, `gte`, `lt`, `lte`, `after`, `before` may be used in ternary conditions.
< 
< 
< im the output Operator types  | Key        | Behavior                 | Type(s)                          | | : |  |  | | eq         | Equals                   | string, number, boolean          | | in         | One of                   | string\[], number\[], boolean\[] | | gt         | Greater than             | string, number                   | | gte        | Greater than or equal to | string, number                   | | lt         | Less than                | string, number                   | | lte        | Less than or equal to    | string, number                   | | startsWith | Starts with              | string                           | | after      | After                    | datetime                         | | before     | Before                   | datetime                         |  Only gt, gte, lt, lte, after, before may be used in ternary conditions.  
< im the input Examples
< 
< #
< im the output Examples  #
< im the input Filtering on a field
< 
< Here we will query our `post` collection with `postConnection` and filter the results by the post `title`:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(filter:#{title:#{startsWith:#&#x22;Vote&#x22;}})#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
< 
< #
< im the output Filtering on a field  Here we will query our post collection with postConnection and filter the results by the post title:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{title:#{startsWith:#&#x22;Vote&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
< im the input Filtering on a field with the IN operator
< 
< Here we will query our `post` collection with `postConnection` and filter the results so that only members of the specified `category` are returned:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]}})#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
< 
< #
< im the output Filtering on a field with the IN operator  Here we will query our post collection with postConnection and filter the results so that only members of the specified category are returned:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
< im the input Filtering on a date range
< 
< Here we will query our `post` collection with `postConnection` and filter the results so that only posts with a `date` between the specified range are returned:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(filter:#{date:#{after:#&#x22;2022-06-01T07:00:00.000Z&#x22;,#before:#&#x22;2022-06-30T07:00:00.000Z&#x22;}})#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
< 
< #
< im the output Filtering on a date range  Here we will query our post collection with postConnection and filter the results so that only posts with a date between the specified range are returned:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{date:#{after:#&#x22;2022-06-01T07:00:00.000Z&#x22;,#before:#&#x22;2022-06-30T07:00:00.000Z&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
< im the input Filtering on multiple fields
< 
< It is possible to filter on multiple fields. Multiple conditions are currently treated as a boolean `AND` operation. Here we will query our `post` collection with `postConnection` and filter the results by `category` and `title`:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]},#title:#{startsWith:#&#x22;Vote&#x22;}})#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
< 
< ##
< im the output Filtering on multiple fields  It is possible to filter on multiple fields. Multiple conditions are currently treated as a boolean AND operation. Here we will query our post collection with postConnection and filter the results by category and title:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]},#title:#{startsWith:#&#x22;Vote&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / ##
< im the input Filtering on a reference
< 
< Here we will query our `post` collection with `postConnection`, and filtering on the referenced `author`'s name:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(filter:#{author:#{author:#{name:#{eq:#&#x22;Napolean&#x22;}}}})#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
< 
< im the output Filtering on a reference  Here we will query our post collection with postConnection, and filtering on the referenced author's name:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{author:#{author:#{name:#{eq:#&#x22;Napolean&#x22;}}}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" /
< im the input 
< There are a number of limitations to keep in mind when leveraging query functionality with Tina's Content API:
< 
< 
< im the output  There are a number of limitations to keep in mind when leveraging query functionality with Tina's Content API:  
< im the input Filter operations
< 
< Some filter operations are not currently supported:
< 
< - Combining conditions using a boolean `OR` operation
< - Negating conditions using a boolean `NOT` operation
< - `exists` operation
< 
< 
< im the output Filter operations  Some filter operations are not currently supported:  - Combining conditions using a boolean OR operation - Negating conditions using a boolean NOT operation - exists operation  
< im the input Numeric value handling
< 
< Numeric values (in both filters and indexed documents) are currently zero-padded to 4 places to provide correct sorting. For example, a field value of `10` would be converted to `0010`. Because of this, numeric values larger than `9999` may currently result in unexpected behavior.
< 
< 
< im the output Numeric value handling  Numeric values (in both filters and indexed documents) are currently zero-padded to 4 places to provide correct sorting. For example, a field value of 10 would be converted to 0010. Because of this, numeric values larger than 9999 may currently result in unexpected behavior.  
< im the input Indexing
< 
< There are several known limitations to keep in mind when using indexes for improved query performance.
< 
< #
< im the output Indexing  There are several known limitations to keep in mind when using indexes for improved query performance.  #
< im the input IN Operators
< 
< Even when an index on a field matches the field(s) of a query filter, the use of the `IN` operator always results in a non-indexed full scan of the collection. This is because it is not possible to construct a single range with start and end values covering the condition.
< 
< #
< im the output IN Operators  Even when an index on a field matches the field(s) of a query filter, the use of the IN operator always results in a non-indexed full scan of the collection. This is because it is not possible to construct a single range with start and end values covering the condition.  #
< im the input Object fields
< 
< A field in a collection that is of type `object` is always ignored during indexing. Because of this, fields within that object cannot be used for sorting. This limitation doesn't prevent filtering results using nested object fields, just sorting on those fields.
< 
< #
< im the output Object fields  A field in a collection that is of type object is always ignored during indexing. Because of this, fields within that object cannot be used for sorting. This limitation doesn't prevent filtering results using nested object fields, just sorting on those fields.  #
< im the input Field type and field order in an index
< 
< A multi-field index may not be usable depending on the `filter` parameter and the order of the fields in the index definition. In order to construct an indexed query, a single range with start and end criteria covering a subset of the collection must be resolvable.
< 
< For example, if the filter for a query specifies a range condition (i.e. `gt`) on one field and another range condition on a different field, then it is impossible to construct a single contiguous range covering both conditions. When such a filter is used the entire collection must be scanned in order to provide consistent sorting and pagination.
< 
< Because of this, when defining a multi-field index, discrete value fields (`boolean` or `string`) should be ordered before any continuous value field (like `datetime` or `numeric` types). This is obviously constrained by use-case and the desired sort order, but is important to keep in mind when considering query performance.
< 
< im the output Field type and field order in an index  A multi-field index may not be usable depending on the filter parameter and the order of the fields in the index definition. In order to construct an indexed query, a single range with start and end criteria covering a subset of the collection must be resolvable.  For example, if the filter for a query specifies a range condition (i.e. gt) on one field and another range condition on a different field, then it is impossible to construct a single contiguous range covering both conditions. When such a filter is used the entire collection must be scanned in order to provide consistent sorting and pagination.  Because of this, when defining a multi-field index, discrete value fields (boolean or string) should be ordered before any continuous value field (like datetime or numeric types). This is obviously constrained by use-case and the desired sort order, but is important to keep in mind when considering query performance. 
< im the input 
< Collection queries implement cursor based pagination. The client specifies a result limit parameter (using `first` or `last`) and a corresponding cursor parameter (using `after` or `before`) which is a pointer to the last item on the previous page of results.
< 
< Both of these parameters are optional. If a result limit is omitted, a maximum of `10` results will be returned. If the cursor is omitted, results will start with the first matching item.
< 
< 
< im the output  Collection queries implement cursor based pagination. The client specifies a result limit parameter (using first or last) and a corresponding cursor parameter (using after or before) which is a pointer to the last item on the previous page of results.  Both of these parameters are optional. If a result limit is omitted, a maximum of 10 results will be returned. If the cursor is omitted, results will start with the first matching item.  
< im the input Page Info
< 
< A `pageInfo` object is available for collection queries and can be used for forward and reverse pagination.
< 
< > In addition to `pageInfo`, each edge in a query result provides a `cursor` field which can also be used for pagination.
< 
< The table below describes the properties available on the `pageInfo` object:
< 
< | Field           | Type    | Description                                                                   |
< | --------------- | ------- | ----------------------------------------------------------------------------- |
< | hasNextPage     | boolean | During forward pagination, indicates if another page of results is available. |
< | hasPreviousPage | boolean | During reverse pagination, indicates if another page of results is available. |
< | startCursor     | string  | The cursor of the first item in the result set.                               |
< | endCursor       | string  | The cursor of the last item in the result set.                                |
< 
< 
< im the output Page Info  A pageInfo object is available for collection queries and can be used for forward and reverse pagination.  In addition to pageInfo, each edge in a query result provides a cursor field which can also be used for pagination.  The table below describes the properties available on the pageInfo object:  | Field           | Type    | Description                                                                   | |  |  |  | | hasNextPage     | boolean | During forward pagination, indicates if another page of results is available. | | hasPreviousPage | boolean | During reverse pagination, indicates if another page of results is available. | | startCursor     | string  | The cursor of the first item in the result set.                               | | endCursor       | string  | The cursor of the last item in the result set.                                |  
< im the input Forward pagination
< 
< To page through query results in the forward direction, the `first` and `after` arguments are used, in combination with the `PageInfo`'s endCursor.
< 
< #
< im the output Forward pagination  To page through query results in the forward direction, the first and after arguments are used, in combination with the PageInfo's endCursor.  #
< im the input Example
< 
< Here we will query our `post` collection with `postConnection`, limiting the page size to `1` and starting at the second item:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(sort:#&#x22;date&#x22;,#first:#1,#after:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;)#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########date
<   ######}
<   ####}
<   ####pageInfo#{
<   ######hasNextPage
<   ######endCursor
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
<   ##########}
<   ########}
<   ######],
<   ######&#x22;pageInfo&#x22;:#{
<   ########&#x22;hasNextPage&#x22;:#true,
<   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;
<   ######}
<   ####}
<   ##}
<   }"
< />
< 
< 
< im the output Example  Here we will query our post collection with postConnection, limiting the page size to 1 and starting at the second item:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;,#first:#1,#after:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ####pageInfo#{   ######hasNextPage   ######endCursor   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########}   ######],   ######&#x22;pageInfo&#x22;:#{   ########&#x22;hasNextPage&#x22;:#true,   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;   ######}   ####}   ##}   }" / 
< im the input Reverse pagination
< 
< To page through query results in the reverse direction, the `last` and `before` arguments are used, in combination with the `PageInfo`'s startCursor.
< 
< #
< im the output Reverse pagination  To page through query results in the reverse direction, the last and before arguments are used, in combination with the PageInfo's startCursor.  #
< im the input Example
< 
< Here we will query our `post` collection with `postConnection`, limiting the page size to `1` and starting at the first item:
< 
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(sort:#&#x22;date&#x22;,#last:#1,#before:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;)#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########date
<   ######}
<   ####}
<   ####pageInfo#{
<   ######hasPreviousPage
<   ######endCursor
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
<   ##########}
<   ########}
<   ######],
<   ######&#x22;pageInfo&#x22;:#{
<   ########&#x22;hasPreviousPage&#x22;:#false,
<   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;
<   ######}
<   ####}
<   ##}
<   }"
< />
< 
< im the output Example  Here we will query our post collection with postConnection, limiting the page size to 1 and starting at the first item:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;,#last:#1,#before:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ####pageInfo#{   ######hasPreviousPage   ######endCursor   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########}   ######],   ######&#x22;pageInfo&#x22;:#{   ########&#x22;hasPreviousPage&#x22;:#false,   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;   ######}   ####}   ##}   }" /
< im the input 
< The GraphQL API indexes on collection fields to provide sorted results when using the `sort` parameter. If a `filter` is specified, the existence of an index can have a large impact on how quickly a query executes.
< 
< Things to keep in mind with indexing:
< 
< - By default, all primary fields on a collection are indexed.
< - Indexing of text fields is limited to the first `100` characters.
< - Object fields on a collection are always excluded from indexing.
< 
< 
< im the output  The GraphQL API indexes on collection fields to provide sorted results when using the sort parameter. If a filter is specified, the existence of an index can have a large impact on how quickly a query executes.  Things to keep in mind with indexing:  - By default, all primary fields on a collection are indexed. - Indexing of text fields is limited to the first 100 characters. - Object fields on a collection are always excluded from indexing.  
< im the input Improving Filtering Performance
< 
< The GraphQL API always attempts to use an appropriate index when executing a query. The `sort` parameter takes precedence over the filter, though, which means sorting by one field and filtering by a different field may result in a slower query execution.
< 
< To improve query performance in scenarios like this, a multi-field index is recommended (as described [here](/docs/graphql/queries/advanced/sorting/#sorting-on-multiple-fields)). If, for example, we want to get only documents in a specific category, sorting by date, a multi-field index should be defined, with the category as the first field, and the date as the second field.
< 
< It is important to remember that the `sort` field _must_ be specified in order for an index to be used. If no `sort` is specified, all items in a collection will be scanned (in filename order).
< 
< > Not all queries can leverage an index. See the [limitations](/docs/graphql/queries/advanced/limitations/#indexing) for more details.
< 
< im the output Improving Filtering Performance  The GraphQL API always attempts to use an appropriate index when executing a query. The sort parameter takes precedence over the filter, though, which means sorting by one field and filtering by a different field may result in a slower query execution.  To improve query performance in scenarios like this, a multi-field index is recommended (as described here. If, for example, we want to get only documents in a specific category, sorting by date, a multi-field index should be defined, with the category as the first field, and the date as the second field.  It is important to remember that the sort field must be specified in order for an index to be used. If no sort is specified, all items in a collection will be scanned (in filename order).  Not all queries can leverage an index. See the limitations for more details. 
< im the input 
< To sort collection results by a collection field, pass the `sort` argument to the `<collection>Connection` query, with the value corresponding to the desired collection field to sort by. Results are returned in ascending order.
< 
< > See [reverse pagination](/docs/graphql/queries/advanced/pagination/) for how to retrieve results in descending order.
< 
< 
< im the output  To sort collection results by a collection field, pass the sort argument to the <collectionConnection query, with the value corresponding to the desired collection field to sort by. Results are returned in ascending order.  See reverse pagination for how to retrieve results in descending order.  
< im the input Sorting on multiple fields
< 
< To sort collection results by multiple fields, we need to define a multi-field "index" in our schema. An index definition determines which fields in a collection are included in the index and the order of the fields when sorting results.
< 
< > In addition to determining the sort order of query results, indexes also impact query [performance](/docs/graphql/queries/advanced/performance/).
< 
< Here is an example index definition for our posts collection:
---
> This name is shown to your users when they log in to the project. Defaults to the repository name.
12666,12685c11908,11910
< ```ts
< {
<   collections: [
<     {
<       label: "Blog Posts",
<       name: "post",
<       path: "content/posts",
<       format: "mdx",
<       fields: [...],
<       indexes: [{
<         name: "category-date",
<         fields: [
<           { name:"category" },
<           { name:"date" }
<         ]
<       }]
<     }
<   ]
< }
< ```
---
> ##
> im the output Project Name  This name is shown to your users when they log in to the project. Defaults to the repository name.  ##
> im the input Site URL(s)
12687c11912
< The `name` property on the index definition is used when referencing it in the `sort` argument. The `fields` property is an ordered list of the fields from the collection that should be indexed, identified by the field `name`. Results returned using the associated sort for this example would be first ordered by `category` and then by `date`.
---
> In these fields, enter both the local URL and the production site URL (if known). For security reasons, Tina will only work at these locations.
12688a11914
> If you are developing locally, this value might be something like:
12690,12691c11916
< im the output Sorting on multiple fields  To sort collection results by multiple fields, we need to define a multi-field "index" in our schema. An index definition determines which fields in a collection are included in the index and the order of the fields when sorting results.  In addition to determining the sort order of query results, indexes also impact query performance.  Here is an example index definition for our posts collection:  ts {   collections: [     {       label: "Blog Posts",       name: "post",       path: "content/posts",       format: "mdx",       fields: [...],       indexes: [{         name: "category-date",         fields: [           { name:"category" },           { name:"date" }         ]       }]     }   ] }   The name property on the index definition is used when referencing it in the sort argument. The fields property is an ordered list of the fields from the collection that should be indexed, identified by the field name. Results returned using the associated sort for this example would be first ordered by category and then by date.  
< im the input Default sort order
---
> `http://localhost:3000`.
12693c11918
< If the `sort` parameter is not specified in a query, results will be returned based on the default filename ordering.
---
> If TinaCloud is configured on your production site, this value might be something like:
12694a11920
> `https://<YOUR-SITE-NAME.com>`
12696,12697c11922
< im the output Default sort order  If the sort parameter is not specified in a query, results will be returned based on the default filename ordering.  
< im the input Examples
---
> > For the Site URL, Only the URL origin is needed. There is no need to include the path to any specific pages.
12698a11924,11931
> ###
> im the output Site URL(s)  In these fields, enter both the local URL and the production site URL (if known). For security reasons, Tina will only work at these locations.  If you are developing locally, this value might be something like:  http://localhost:3000.  If TinaCloud is configured on your production site, this value might be something like:  https://<YOUR-SITE-NAME.com For the Site URL, Only the URL origin is needed. There is no need to include the path to any specific pages.  ###
> im the input Glob Patterns
> 
> Tina also supports Glob patterns for the Site URL. This can be useful if you want to allow editing on dynamic preview deployments.
> 
> E.g. on Vercel this may look like: `https://<VERCEL-PROJECT-NAME>-*-<VERCEL-ACCOUNT-OWNER>.vercel.app`
> 
12700,12701c11933,11934
< im the output Examples  #
< im the input Sorting by a single field
---
> im the output Glob Patterns  Tina also supports Glob patterns for the Site URL. This can be useful if you want to allow editing on dynamic preview deployments.  E.g. on Vercel this may look like: https://<VERCEL-PROJECT-NAME--<VERCEL-ACCOUNT-OWNER.vercel.app  #
> im the input 4. Using the project
12703c11936
< Here we will query our `post` collection with `postConnection` and sort the results by the `date` field:
---
> Once your project is created, you will see it listed on your [Projects](https://app.tina.io/projects) page.
12705,12746d11937
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(sort:#&#x22;date&#x22;)#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########date
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
12747a11939,11941
> im the output 4. Using the project  Once your project is created, you will see it listed on your Projects page.  
> im the input Administering the project
> 
12749,12750c11943,11944
< im the output Sorting by a single field  Here we will query our post collection with postConnection and sort the results by the date field:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
< im the input Sorting by multiple fields
---
> im the output Administering the project  #
> im the input Overview
12752c11946
< Here we will query our `post` collection with `postConnection` and sort the results first by `category` and then by `date` using the multi-field index named `category-date`:
---
> A project's Overview page gives you an important value: your project's unique **Client ID**. This value is used by TinaCloud to connect to your site's repository. You will need to use this value when setting up your site to use Tina.
12754,12799c11948,11950
< <GraphQLCodeBlock
<   query="{
<   ##postConnection(sort:#&#x22;category-date&#x22;)#{
<   ####edges#{
<   ######node#{
<   ########id
<   ########title
<   ########category
<   ########date
<   ######}
<   ####}
<   ##}
<   }"
<   response="{
<   ##&#x22;data&#x22;:#{
<   ####&#x22;postConnection&#x22;:#{
<   ######&#x22;edges&#x22;:#[
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
<   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
<   ##########}
<   ########},
<   ########{
<   ##########&#x22;node&#x22;:#{
<   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
<   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
<   ############&#x22;category&#x22;:#&#x22;politics&#x22;,
<   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
<   ##########}
<   ########}
<   ######]
<   ####}
<   ##}
<   }"
< />
---
> #
> im the output Overview  A project's Overview page gives you an important value: your project's unique Client ID. This value is used by TinaCloud to connect to your site's repository. You will need to use this value when setting up your site to use Tina.  #
> im the input Configuration
12801c11952,12037
< im the output Sorting by multiple fields  Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;category-date&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########category   ########date   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########}   ######]   ####}   ##}   }" /
---
> After your project has been created, you can visit the Configuration page to update the Project Name, Site URL(s), or the GitHub repository
> 
> ##
> im the output Configuration  After your project has been created, you can visit the Configuration page to update the Project Name, Site URL(s), or the GitHub repository  ##
> im the input Changing the Repository
> 
> From the project configuration screen, click the "Change Repository" button. You will authorize Tina.io again and a list of repositories will be displayed. Selecting the new repository and click Save Project to update the repository.
> 
> ##
> im the output Changing the Repository  From the project configuration screen, click the "Change Repository" button. You will authorize Tina.io again and a list of repositories will be displayed. Selecting the new repository and click Save Project to update the repository.  ##
> im the input Advanced Settings
> 
> The Advanced Settings button is located in the Configuration tab of your project in TinaCloud.
> 
> ###
> im the output Advanced Settings  The Advanced Settings button is located in the Configuration tab of your project in TinaCloud.  ###
> im the input Path To Tina
> 
> If your \`tina\` directory is at the project root (as is for most site), this field can be left blank.\
> \
> If your GitHub repository uses a monorepo structure, the Path To Tina Config input can be used to specify the path to the
> `tina` directory in your repository. For example, if you have a project named `my-site`, and it is located in the
> `projects` directory of your repository, you would enter `projects/my-site` in this field and click Save Project to
> update the project.
> 
> ###
> im the output Path To Tina  If your \tina\ directory is at the project root (as is for most site), this field can be left blank.\ \ If your GitHub repository uses a monorepo structure, the Path To Tina Config input can be used to specify the path to the tina directory in your repository. For example, if you have a project named my-site, and it is located in the projects directory of your repository, you would enter projects/my-site in this field and click Save Project to update the project.  ###
> im the input Refresh Webhooks
> 
> In rare circumstances, the GitHub Webhook connecting your repository to TinaCloud may be disrupted. If the webhook does
> not execute, TinaCloud may become out of sync with your GitHub repository. Click the "Refresh Webhooks" button to restore them.
> 
> ###
> im the output Refresh Webhooks  In rare circumstances, the GitHub Webhook connecting your repository to TinaCloud may be disrupted. If the webhook does not execute, TinaCloud may become out of sync with your GitHub repository. Click the "Refresh Webhooks" button to restore them.  ###
> im the input Export Branch
> 
> Clicking this opens a modal dialog that allows you to push a new branch with the changes from an existing branch at a
> particular point in time. First select the branch where the changes are located under Source Branch. An export branch
> name is auto-generated from this selection, but can also be edited as desired as long as it doesn't conflict with an
> existing branch name. Next, select the point in time from which you want to push the changes, either
> 'Last Successful Push' or a custom date in the past. Once these selections are made, click the 'Export Branch' button. After
> a few minutes, the new branch will be available in your GitHub repository with any changes in TinaCloud. A pull request
> can then be created to merge the changes to your desired branch.
> 
> ###
> im the output Export Branch  Clicking this opens a modal dialog that allows you to push a new branch with the changes from an existing branch at a particular point in time. First select the branch where the changes are located under Source Branch. An export branch name is auto-generated from this selection, but can also be edited as desired as long as it doesn't conflict with an existing branch name. Next, select the point in time from which you want to push the changes, either 'Last Successful Push' or a custom date in the past. Once these selections are made, click the 'Export Branch' button. After a few minutes, the new branch will be available in your GitHub repository with any changes in TinaCloud. A pull request can then be created to merge the changes to your desired branch.  ###
> im the input Branch "Reindex"
> 
> Clicking "Reindex" on a branch will completely reset the cached copy of that branch in your GitHub repository and initiate a reindexing process. Any changes only present in the cached copy will be lost. Before reindexing, you should ensure that any changes have
> been successfully pushed to GitHub using the Export Branch feature.
> 
> #
> im the output Branch "Reindex"  Clicking "Reindex" on a branch will completely reset the cached copy of that branch in your GitHub repository and initiate a reindexing process. Any changes only present in the cached copy will be lost. Before reindexing, you should ensure that any changes have been successfully pushed to GitHub using the Export Branch feature.  #
> im the input API tokens
> 
> There are two types of tokens associated with projects in TinaCloud: Content (Read-only) and Search.
> 
> - Content tokens provide read-only access to your project's content.
> - Search tokens provide write access to the TinaCloud search API.
> 
> <WarningCallout body="Warning: API tokens should be considered sensitive and not be committed to your project repository. Content tokens allow clients read-only access to your repository content. Search tokens allow clients to update the TinaCloud hosted search index for your site. Please use environment variables for these in your Tina configuration." />
> 
> ##
> im the output API tokens  There are two types of tokens associated with projects in TinaCloud: Content (Read-only) and Search.  - Content tokens provide read-only access to your project's content. - Search tokens provide write access to the TinaCloud search API.  <WarningCallout body="Warning: API tokens should be considered sensitive and not be committed to your project repository. Content tokens allow clients read-only access to your repository content. Search tokens allow clients to update the TinaCloud hosted search index for your site. Please use environment variables for these in your Tina configuration." / ##
> im the input Generate tokens from the dashboard
> 
> By default, a new project will automatically generate both types of tokens with access to all branch types. If the project does not need to restrict access to specific branches, these tokens should be sufficient.
> 
> If additional tokens are needed, they can be generated by navigating to [TinaCloud](https://app.tina.io), clicking on the project you wish to add a token to, and clicking on the "Tokens" tab:
> ![TinaCloud token tab](https://res.cloudinary.com/forestry-demo/image/upload/v1686248278/tina-io/docs/tina-cloud/api_tokens_list_v1_mmjpsp.png)
> 
> Next, click "New Token" and fill out fields. The "Type" field selects the type of token being created. "Name" is used for identifying the token. "Git Branches" is the list of branches (separated by commas) that the token has access to.
> 
> ![Creating a new token in TinaCloud](https://res.cloudinary.com/forestry-demo/image/upload/v1686248661/tina-io/docs/tina-cloud/new_api_token_v1_lq1rfy.png)
> 
> These tokens will be used later when we connect the site's frontend to our project.
> 
> ##
> im the output Generate tokens from the dashboard  By default, a new project will automatically generate both types of tokens with access to all branch types. If the project does not need to restrict access to specific branches, these tokens should be sufficient.  If additional tokens are needed, they can be generated by navigating to TinaCloud, clicking on the project you wish to add a token to, and clicking on the "Tokens" tab:   Next, click "New Token" and fill out fields. The "Type" field selects the type of token being created. "Name" is used for identifying the token. "Git Branches" is the list of branches (separated by commas) that the token has access to.    These tokens will be used later when we connect the site's frontend to our project.  ##
> im the input Wild cards in branch names
> 
> Wild card matching is supported in branch names using '\*' to match anything. For example: `feat/*` will match both `feat/foo` and `feat/bar`. If only `*` is entered it will match any branch.
> 
> Wild card matching is useful for matching branches that have not been created yet and can be used for editorial workflows.
> 
> im the output Wild cards in branch names  Wild card matching is supported in branch names using '\' to match anything. For example: feat/ will match both feat/foo and feat/bar. If only  is entered it will match any branch.  Wild card matching is useful for matching branches that have not been created yet and can be used for editorial workflows. 
12802a12039,12239
> Register for TinaCloud by navigating to the [registration page](https://app.tina.io/register).
> 
> You can register with either an existing GitHub account or create a new TinaCloud account:
> 
> ![tina-cloud-registration](/img/cloud-registration.png)
> 
> Once your account is verified, you will be able to login and access the dashboard.
> 
> im the output  Register for TinaCloud by navigating to the registration page.  You can register with either an existing GitHub account or create a new TinaCloud account:    Once your account is verified, you will be able to login and access the dashboard. 
> im the input 
> The **Collaborations** tab of a project allows users manage a project.
> 
> Project collaborators can have one of the following project-level roles:
> 
> - Editor
> - Admin
> 
> The following roles/permissions apply to "Project Admins" & "Project Editors":
> 
> | Actions                      | Project Admin | Project Editor |
> | ---------------------------- | ------------- | -------------- |
> | Edit Project Content         |             |              |
> | View Project Overview        |             |              |
> | Manage Project Configuration |             |              |
> | Manage Project Collaborators |             |              |
> 
> Both Admins and Editors are authorized to access the editing route on a Tina configured site. Both users can save content changes directly to a site's GitHub repository using TinaCMS.
> 
> > When a site is configured to use TinaCloud, an authorized user will be prompted for their TinaCloud credentials to access the editing route of the site.
> 
> im the output  The Collaborations tab of a project allows users manage a project.  Project collaborators can have one of the following project-level roles:  - Editor - Admin  The following roles/permissions apply to "Project Admins" & "Project Editors":  | Actions                      | Project Admin | Project Editor | |  |  |  | | Edit Project Content         |             |              | | View Project Overview        |             |              | | Manage Project Configuration |             |              | | Manage Project Collaborators |             |              |  Both Admins and Editors are authorized to access the editing route on a Tina configured site. Both users can save content changes directly to a site's GitHub repository using TinaCMS.  When a site is configured to use TinaCloud, an authorized user will be prompted for their TinaCloud credentials to access the editing route of the site. 
> im the input 
> GitHub Pages is a popular hosting option for static sites. GitHub Pages can be configured in **\<your-repo>** > **Settings** > **Pages**.
> 
> 
> im the output  GitHub Pages is a popular hosting option for static sites. GitHub Pages can be configured in \<your-repoSettings Pages.  
> im the input Build Configuration
> 
> GitHub Pages offers a few build options:
> 
> - GitHub Actions
> - Deploy from a branch
> 
> ![GitHub Actions](https://res.cloudinary.com/forestry-demo/image/upload/v1674654344/tina-io/docs/tina-cloud/Screen_Shot_2023-01-25_at_9.40.52_AM_fby9q2.png 'GitHub Actions')
> 
> We want to choose "**GitHub Actions**" so that we can control the build script, and make sure it's also building the TinaCMS admin
> 
> By clicking "Configure" on the action it's created for us, we can then tweak the build script to build tinacms along with our site.
> 
> Add the following step **before** your site's build step:
> 
> If you are using npm as your package name, you can use the following:
> 
> ```yml
> - name: Build TinaCMS
>   env:
>     TINA_PUBLIC_CLIENT_ID: ${{ secrets.TINA_PUBLIC_CLIENT_ID }}
>     TINA_TOKEN: ${{ secrets.TINA_TOKEN }}
>   run: npx tinacms build
> ```
> 
> or if you are using yarn:
> 
> ```yml
> - name: Build TinaCMS
>   env:
>     TINA_PUBLIC_CLIENT_ID: ${{ secrets.TINA_PUBLIC_CLIENT_ID }}
>     TINA_TOKEN: ${{ secrets.TINA_TOKEN }}
>   run: yarn build
>   # This assumes that your "build" script in your
>   # package.json is "tinacms build"
> ```
> 
> Your GitHub Action will look something like:
> 
> ![GitHub Action](https://res.cloudinary.com/forestry-demo/image/upload/v1675783496/tina-io/docs/tina-cloud/gh-config.png 'GitHub Action')
> 
> 
> im the output Build Configuration  GitHub Pages offers a few build options:  - GitHub Actions - Deploy from a branch    We want to choose "GitHub Actions" so that we can control the build script, and make sure it's also building the TinaCMS admin  By clicking "Configure" on the action it's created for us, we can then tweak the build script to build tinacms along with our site.  Add the following step before your site's build step:  If you are using npm as your package name, you can use the following:  yml - name: Build TinaCMS   env:     TINAPUBLICCLIENTID: $     TINATOKEN: $   run: npx tinacms build   or if you are using yarn:  yml - name: Build TinaCMS   env:     TINAPUBLICCLIENTID: $     TINATOKEN: $   run: yarn build   This assumes that your "build" script in your   package.json is "tinacms build"   Your GitHub Action will look something like:    
> im the input Common Issues
> 
> #
> im the output Common Issues  #
> im the input Common Issue: 'Missing script: "tinacms"'
> 
> This error might occur from the following reasons:
> 
> ##
> im the output Common Issue: 'Missing script: "tinacms"'  This error might occur from the following reasons:  ##
> im the input 1. tinacms dependencies not added to package.json.
> 
> Make sure that both the `tinacms` & `@tinacms/cli` dependencies are listed in your package.json.
> 
> ##
> im the output 1. tinacms dependencies not added to package.json.  Make sure that both the tinacms & @tinacms/cli dependencies are listed in your package.json.  ##
> im the input 2. Dependencies aren't being installed in CI.
> 
> If you are using npm make sure that `npm ci` is being run before the TinaCMS build command. If you are using yarn, make sure you are running `yarn install --frozen-lockfile` before running the build command.
> 
> ##
> im the output 2. Dependencies aren't being installed in CI.  If you are using npm make sure that npm ci is being run before the TinaCMS build command. If you are using yarn, make sure you are running yarn install --frozen-lockfile before running the build command.  ##
> im the input 3. Needing to define a 'tinacms' script.
> 
> If your CI is running something like `yarn tinacms build` instead of `npx tinacms build`, you'll need to add a custom script to your package.json:
> 
> ```json
>   "scripts": {
>     "tinacms": "tinacms",
>     // ...
> ```
> 
> #
> im the output 3. Needing to define a 'tinacms' script.  If your CI is running something like yarn tinacms build instead of npx tinacms build, you'll need to add a custom script to your package.json:  json   "scripts": {     "tinacms": "tinacms",     // ...   #
> im the input Common Issue: /admin is giving a 404
> 
> This can happen for a number of reasons but here are the most common reasons and fixes:
> 
> ##
> im the output Common Issue: /admin is giving a 404  This can happen for a number of reasons but here are the most common reasons and fixes:  ##
> im the input 1. Not providing a custom build workflow
> 
> If your site is deploying with GitHub Pages, it may be using GitHub's default build steps. In this case, TinaCMS won't be included in the build.
> 
> ![GitHub Pages configuration](https://res.cloudinary.com/forestry-demo/image/upload/v1683212636/gh-pages.png).
> 
> To fix this, you'll need to select the "GitHub Actions" source, and build the tinacms admin along with your site. You can see our doc above for help setting up this GitHub Action.
> 
> ##
> im the output 1. Not providing a custom build workflow  If your site is deploying with GitHub Pages, it may be using GitHub's default build steps. In this case, TinaCMS won't be included in the build.  .  To fix this, you'll need to select the "GitHub Actions" source, and build the tinacms admin along with your site. You can see our doc above for help setting up this GitHub Action.  ##
> im the input 2. 'tinacms build' is not running in CI
> 
> Check to make sure that the build command is running and not failing
> 
> > Note: If you are using [the github pages setup from hugo](https://gohugo.io/hosting-and-deployment/hosting-on-github/) you will need to make sure that a `package-lock.json` exists in the root of your repo.
> 
> #
> im the output 2. 'tinacms build' is not running in CI  Check to make sure that the build command is running and not failing  Note: If you are using the github pages setup from hugo you will need to make sure that a package-lock.json exists in the root of your repo.  #
> im the input Common Issue: The root URL is giving a 404
> 
> This is usually due to a missing entrypoint file for GitHub Pages.
> 
> To fix this, you'll need to create a file named `index.tsx` in the `./pages` directory. Your `index.tsx` should look something like this:
> 
> ```ts
> import Filename, { getStaticProps as FilenameStaticProps } from './[filename]';
> 
> const Index = Filename;
> 
> export const getStaticProps = async ({ params }) => {
>   return FilenameStaticProps({ params: { filename: 'home' } });
> }
> 
> export default Index;
> ```
> 
> 
> im the output Common Issue: The root URL is giving a 404  This is usually due to a missing entrypoint file for GitHub Pages.  To fix this, you'll need to create a file named index.tsx in the ./pages directory. Your index.tsx should look something like this:  ts import Filename, { getStaticProps as FilenameStaticProps } from './[filename]';  const Index = Filename;  export const getStaticProps = async ({ params }) ={   return FilenameStaticProps({ params: { filename: 'home' } }); }  export default Index;   
> im the input Environment variables
> 
> Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the GitHub Secrets for your project. The secrets we used in the code snippet above were `TINA_PUBLIC_CLIENT_ID` & `TINA_TOKEN`.
> 
> im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the GitHub Secrets for your project. The secrets we used in the code snippet above were TINAPUBLICCLIENTID & TINATOKEN. 
> im the input 
> 
> im the output  
> im the input Build Configuration
> 
> In Netlify, your build configuration can be updated at **Settings** > **Build & Deploy** > **Build Command**.
> 
> ![Netlify build config](https://res.cloudinary.com/forestry-demo/image/upload/v1674607585/Screen_Shot_2023-01-24_at_8.45.23_PM_gbqyqb.png 'Netlify build config')
> 
> > If your package.json has a "build" script like `tinacms build && <your-site-build-cmd>`, this likely doesn't need to be changed. If your Netlify config is not running a custom build script (e.g `next build`), you would have to change this to `tinacms build && next build`
> 
> > If your project has a `netlify.toml` with a build command set, that will take precedence over the above build command UI
> 
> 
> im the output Build Configuration  In Netlify, your build configuration can be updated at Settings Build & Deploy Build Command.    If your package.json has a "build" script like tinacms build && <your-site-build-cmd, this likely doesn't need to be changed. If your Netlify config is not running a custom build script (e.g next build), you would have to change this to tinacms build && next build  If your project has a netlify.toml with a build command set, that will take precedence over the above build command UI  
> im the input Environment variables
> 
> Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the Netlify UI for your project. You can learn more about environment variables [here](https://docs.netlify.com/environment-variables/overview/?_ga=2.128850127.213489666.1674607241-1149277376.1674150726 'netlify environment variables').
> 
> im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the Netlify UI for your project. You can learn more about environment variables here. 
> im the input 
> 
> im the output  
> im the input Build Configuration
> 
> In Vercel, your build configuration can be updated at **Settings** > **General** > **Build & Development Settings**.
> 
> ![Vercel Build Settings](https://res.cloudinary.com/forestry-demo/image/upload/v1674653527/tina-io/docs/tina-cloud/vercel-build-settings_vubza8.png 'Vercel Build Settings')
> 
> > If your package.json has a "build" script like `tinacms build && <your-site-build-cmd>`, this likely doesn't need to be changed. If your Vercel config is not running a custom build script (e.g `next build` instead of `npm run build`), you would have to change this to `tinacms build && next build`
> 
> 
> im the output Build Configuration  In Vercel, your build configuration can be updated at Settings General Build & Development Settings.    If your package.json has a "build" script like tinacms build && <your-site-build-cmd, this likely doesn't need to be changed. If your Vercel config is not running a custom build script (e.g next build instead of npm run build), you would have to change this to tinacms build && next build  
> im the input Environment variables
> 
> Assuming that your Tina `clientID` and `token` are setup as environment variables, you will need to add those to the Vercel "Environment Variables" tab for your project.
> 
> im the output Environment variables  Assuming that your Tina clientID and token are setup as environment variables, you will need to add those to the Vercel "Environment Variables" tab for your project. 
> im the input 
13607a13045,13607
> Tina automatically creates filters for collections defined in your schema.
> 
> To filter collection results, pass the `filter` argument to the `<collection>Connection` query, followed by any of the filter [operator types](/docs/graphql/queries/advanced/filter-documents/#operator-types) for the fields on your collection.
> 
> The `filter` object is a nested set of conditions where the keys correspond to the collection field and the value describes the condition.
> 
> Conditions can be either "binary" or "ternary". A binary condition is composed of a single operator and a single operand (i.e. `{"eq":"foo"}`). A ternary condition is composed of two operators and two operands (.i.e. `{"gt":0, "lte": 10}`).
> 
> 
> im the output  Tina automatically creates filters for collections defined in your schema.  To filter collection results, pass the filter argument to the <collectionConnection query, followed by any of the filter operator types for the fields on your collection.  The filter object is a nested set of conditions where the keys correspond to the collection field and the value describes the condition.  Conditions can be either "binary" or "ternary". A binary condition is composed of a single operator and a single operand (i.e. {"eq":"foo"}). A ternary condition is composed of two operators and two operands (.i.e. {"gt":0, "lte": 10}).  
> im the input Operator types
> 
> | Key        | Behavior                 | Type(s)                          |
> | :--------- | ------------------------ | -------------------------------- |
> | eq         | Equals                   | string, number, boolean          |
> | in         | One of                   | string\[], number\[], boolean\[] |
> | gt         | Greater than             | string, number                   |
> | gte        | Greater than or equal to | string, number                   |
> | lt         | Less than                | string, number                   |
> | lte        | Less than or equal to    | string, number                   |
> | startsWith | Starts with              | string                           |
> | after      | After                    | datetime                         |
> | before     | Before                   | datetime                         |
> 
> > Only `gt`, `gte`, `lt`, `lte`, `after`, `before` may be used in ternary conditions.
> 
> 
> im the output Operator types  | Key        | Behavior                 | Type(s)                          | | : |  |  | | eq         | Equals                   | string, number, boolean          | | in         | One of                   | string\[], number\[], boolean\[] | | gt         | Greater than             | string, number                   | | gte        | Greater than or equal to | string, number                   | | lt         | Less than                | string, number                   | | lte        | Less than or equal to    | string, number                   | | startsWith | Starts with              | string                           | | after      | After                    | datetime                         | | before     | Before                   | datetime                         |  Only gt, gte, lt, lte, after, before may be used in ternary conditions.  
> im the input Examples
> 
> #
> im the output Examples  #
> im the input Filtering on a field
> 
> Here we will query our `post` collection with `postConnection` and filter the results by the post `title`:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(filter:#{title:#{startsWith:#&#x22;Vote&#x22;}})#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> #
> im the output Filtering on a field  Here we will query our post collection with postConnection and filter the results by the post title:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{title:#{startsWith:#&#x22;Vote&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
> im the input Filtering on a field with the IN operator
> 
> Here we will query our `post` collection with `postConnection` and filter the results so that only members of the specified `category` are returned:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]}})#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> #
> im the output Filtering on a field with the IN operator  Here we will query our post collection with postConnection and filter the results so that only members of the specified category are returned:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
> im the input Filtering on a date range
> 
> Here we will query our `post` collection with `postConnection` and filter the results so that only posts with a `date` between the specified range are returned:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(filter:#{date:#{after:#&#x22;2022-06-01T07:00:00.000Z&#x22;,#before:#&#x22;2022-06-30T07:00:00.000Z&#x22;}})#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> #
> im the output Filtering on a date range  Here we will query our post collection with postConnection and filter the results so that only posts with a date between the specified range are returned:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{date:#{after:#&#x22;2022-06-01T07:00:00.000Z&#x22;,#before:#&#x22;2022-06-30T07:00:00.000Z&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
> im the input Filtering on multiple fields
> 
> It is possible to filter on multiple fields. Multiple conditions are currently treated as a boolean `AND` operation. Here we will query our `post` collection with `postConnection` and filter the results by `category` and `title`:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]},#title:#{startsWith:#&#x22;Vote&#x22;}})#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> ##
> im the output Filtering on multiple fields  It is possible to filter on multiple fields. Multiple conditions are currently treated as a boolean AND operation. Here we will query our post collection with postConnection and filter the results by category and title:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{category:#{in:#[&#x22;politics&#x22;]},#title:#{startsWith:#&#x22;Vote&#x22;}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / ##
> im the input Filtering on a reference
> 
> Here we will query our `post` collection with `postConnection`, and filtering on the referenced `author`'s name:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(filter:#{author:#{author:#{name:#{eq:#&#x22;Napolean&#x22;}}}})#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> im the output Filtering on a reference  Here we will query our post collection with postConnection, and filtering on the referenced author's name:  <GraphQLCodeBlock   query="{   ##postConnection(filter:#{author:#{author:#{name:#{eq:#&#x22;Napolean&#x22;}}}})#{   ####edges#{   ######node#{   ########id   ########title   ########category   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;   ##########}   ########}   ######]   ####}   ##}   }" /
> im the input 
> There are a number of limitations to keep in mind when leveraging query functionality with Tina's Content API:
> 
> 
> im the output  There are a number of limitations to keep in mind when leveraging query functionality with Tina's Content API:  
> im the input Filter operations
> 
> Some filter operations are not currently supported:
> 
> - Combining conditions using a boolean `OR` operation
> - Negating conditions using a boolean `NOT` operation
> - `exists` operation
> 
> 
> im the output Filter operations  Some filter operations are not currently supported:  - Combining conditions using a boolean OR operation - Negating conditions using a boolean NOT operation - exists operation  
> im the input Numeric value handling
> 
> Numeric values (in both filters and indexed documents) are currently zero-padded to 4 places to provide correct sorting. For example, a field value of `10` would be converted to `0010`. Because of this, numeric values larger than `9999` may currently result in unexpected behavior.
> 
> 
> im the output Numeric value handling  Numeric values (in both filters and indexed documents) are currently zero-padded to 4 places to provide correct sorting. For example, a field value of 10 would be converted to 0010. Because of this, numeric values larger than 9999 may currently result in unexpected behavior.  
> im the input Indexing
> 
> There are several known limitations to keep in mind when using indexes for improved query performance.
> 
> #
> im the output Indexing  There are several known limitations to keep in mind when using indexes for improved query performance.  #
> im the input IN Operators
> 
> Even when an index on a field matches the field(s) of a query filter, the use of the `IN` operator always results in a non-indexed full scan of the collection. This is because it is not possible to construct a single range with start and end values covering the condition.
> 
> #
> im the output IN Operators  Even when an index on a field matches the field(s) of a query filter, the use of the IN operator always results in a non-indexed full scan of the collection. This is because it is not possible to construct a single range with start and end values covering the condition.  #
> im the input Object fields
> 
> A field in a collection that is of type `object` is always ignored during indexing. Because of this, fields within that object cannot be used for sorting. This limitation doesn't prevent filtering results using nested object fields, just sorting on those fields.
> 
> #
> im the output Object fields  A field in a collection that is of type object is always ignored during indexing. Because of this, fields within that object cannot be used for sorting. This limitation doesn't prevent filtering results using nested object fields, just sorting on those fields.  #
> im the input Field type and field order in an index
> 
> A multi-field index may not be usable depending on the `filter` parameter and the order of the fields in the index definition. In order to construct an indexed query, a single range with start and end criteria covering a subset of the collection must be resolvable.
> 
> For example, if the filter for a query specifies a range condition (i.e. `gt`) on one field and another range condition on a different field, then it is impossible to construct a single contiguous range covering both conditions. When such a filter is used the entire collection must be scanned in order to provide consistent sorting and pagination.
> 
> Because of this, when defining a multi-field index, discrete value fields (`boolean` or `string`) should be ordered before any continuous value field (like `datetime` or `numeric` types). This is obviously constrained by use-case and the desired sort order, but is important to keep in mind when considering query performance.
> 
> im the output Field type and field order in an index  A multi-field index may not be usable depending on the filter parameter and the order of the fields in the index definition. In order to construct an indexed query, a single range with start and end criteria covering a subset of the collection must be resolvable.  For example, if the filter for a query specifies a range condition (i.e. gt) on one field and another range condition on a different field, then it is impossible to construct a single contiguous range covering both conditions. When such a filter is used the entire collection must be scanned in order to provide consistent sorting and pagination.  Because of this, when defining a multi-field index, discrete value fields (boolean or string) should be ordered before any continuous value field (like datetime or numeric types). This is obviously constrained by use-case and the desired sort order, but is important to keep in mind when considering query performance. 
> im the input 
> Collection queries implement cursor based pagination. The client specifies a result limit parameter (using `first` or `last`) and a corresponding cursor parameter (using `after` or `before`) which is a pointer to the last item on the previous page of results.
> 
> Both of these parameters are optional. If a result limit is omitted, a maximum of `10` results will be returned. If the cursor is omitted, results will start with the first matching item.
> 
> 
> im the output  Collection queries implement cursor based pagination. The client specifies a result limit parameter (using first or last) and a corresponding cursor parameter (using after or before) which is a pointer to the last item on the previous page of results.  Both of these parameters are optional. If a result limit is omitted, a maximum of 10 results will be returned. If the cursor is omitted, results will start with the first matching item.  
> im the input Page Info
> 
> A `pageInfo` object is available for collection queries and can be used for forward and reverse pagination.
> 
> > In addition to `pageInfo`, each edge in a query result provides a `cursor` field which can also be used for pagination.
> 
> The table below describes the properties available on the `pageInfo` object:
> 
> | Field           | Type    | Description                                                                   |
> | --------------- | ------- | ----------------------------------------------------------------------------- |
> | hasNextPage     | boolean | During forward pagination, indicates if another page of results is available. |
> | hasPreviousPage | boolean | During reverse pagination, indicates if another page of results is available. |
> | startCursor     | string  | The cursor of the first item in the result set.                               |
> | endCursor       | string  | The cursor of the last item in the result set.                                |
> 
> 
> im the output Page Info  A pageInfo object is available for collection queries and can be used for forward and reverse pagination.  In addition to pageInfo, each edge in a query result provides a cursor field which can also be used for pagination.  The table below describes the properties available on the pageInfo object:  | Field           | Type    | Description                                                                   | |  |  |  | | hasNextPage     | boolean | During forward pagination, indicates if another page of results is available. | | hasPreviousPage | boolean | During reverse pagination, indicates if another page of results is available. | | startCursor     | string  | The cursor of the first item in the result set.                               | | endCursor       | string  | The cursor of the last item in the result set.                                |  
> im the input Forward pagination
> 
> To page through query results in the forward direction, the `first` and `after` arguments are used, in combination with the `PageInfo`'s endCursor.
> 
> #
> im the output Forward pagination  To page through query results in the forward direction, the first and after arguments are used, in combination with the PageInfo's endCursor.  #
> im the input Example
> 
> Here we will query our `post` collection with `postConnection`, limiting the page size to `1` and starting at the second item:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(sort:#&#x22;date&#x22;,#first:#1,#after:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;)#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########date
>   ######}
>   ####}
>   ####pageInfo#{
>   ######hasNextPage
>   ######endCursor
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
>   ##########}
>   ########}
>   ######],
>   ######&#x22;pageInfo&#x22;:#{
>   ########&#x22;hasNextPage&#x22;:#true,
>   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;
>   ######}
>   ####}
>   ##}
>   }"
> />
> 
> 
> im the output Example  Here we will query our post collection with postConnection, limiting the page size to 1 and starting at the second item:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;,#first:#1,#after:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ####pageInfo#{   ######hasNextPage   ######endCursor   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########}   ######],   ######&#x22;pageInfo&#x22;:#{   ########&#x22;hasNextPage&#x22;:#true,   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;   ######}   ####}   ##}   }" / 
> im the input Reverse pagination
> 
> To page through query results in the reverse direction, the `last` and `before` arguments are used, in combination with the `PageInfo`'s startCursor.
> 
> #
> im the output Reverse pagination  To page through query results in the reverse direction, the last and before arguments are used, in combination with the PageInfo's startCursor.  #
> im the input Example
> 
> Here we will query our `post` collection with `postConnection`, limiting the page size to `1` and starting at the first item:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(sort:#&#x22;date&#x22;,#last:#1,#before:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;)#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########date
>   ######}
>   ####}
>   ####pageInfo#{
>   ######hasPreviousPage
>   ######endCursor
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
>   ##########}
>   ########}
>   ######],
>   ######&#x22;pageInfo&#x22;:#{
>   ########&#x22;hasPreviousPage&#x22;:#false,
>   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;
>   ######}
>   ####}
>   ##}
>   }"
> />
> 
> im the output Example  Here we will query our post collection with postConnection, limiting the page size to 1 and starting at the first item:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;,#last:#1,#before:#&#x22;cG9zdCNkYXRlIzE2NTc4Njg0MDAwMDAjY29udGVudC9wb3N0cy9hbm90aGVyUG9zdC5qc29u&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ####pageInfo#{   ######hasPreviousPage   ######endCursor   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########}   ######],   ######&#x22;pageInfo&#x22;:#{   ########&#x22;hasPreviousPage&#x22;:#false,   ########&#x22;endCursor&#x22;:#&#x22;cG9zdCNkYXRlIzE2NTUyNzY0MDAwMDAjY29udGVudC9wb3N0cy92b3RlRm9yUGVkcm8uanNvbg==&#x22;   ######}   ####}   ##}   }" /
> im the input 
> The GraphQL API indexes on collection fields to provide sorted results when using the `sort` parameter. If a `filter` is specified, the existence of an index can have a large impact on how quickly a query executes.
> 
> Things to keep in mind with indexing:
> 
> - By default, all primary fields on a collection are indexed.
> - Indexing of text fields is limited to the first `100` characters.
> - Object fields on a collection are always excluded from indexing.
> 
> 
> im the output  The GraphQL API indexes on collection fields to provide sorted results when using the sort parameter. If a filter is specified, the existence of an index can have a large impact on how quickly a query executes.  Things to keep in mind with indexing:  - By default, all primary fields on a collection are indexed. - Indexing of text fields is limited to the first 100 characters. - Object fields on a collection are always excluded from indexing.  
> im the input Improving Filtering Performance
> 
> The GraphQL API always attempts to use an appropriate index when executing a query. The `sort` parameter takes precedence over the filter, though, which means sorting by one field and filtering by a different field may result in a slower query execution.
> 
> To improve query performance in scenarios like this, a multi-field index is recommended (as described [here](/docs/graphql/queries/advanced/sorting/#sorting-on-multiple-fields)). If, for example, we want to get only documents in a specific category, sorting by date, a multi-field index should be defined, with the category as the first field, and the date as the second field.
> 
> It is important to remember that the `sort` field _must_ be specified in order for an index to be used. If no `sort` is specified, all items in a collection will be scanned (in filename order).
> 
> > Not all queries can leverage an index. See the [limitations](/docs/graphql/queries/advanced/limitations/#indexing) for more details.
> 
> im the output Improving Filtering Performance  The GraphQL API always attempts to use an appropriate index when executing a query. The sort parameter takes precedence over the filter, though, which means sorting by one field and filtering by a different field may result in a slower query execution.  To improve query performance in scenarios like this, a multi-field index is recommended (as described here. If, for example, we want to get only documents in a specific category, sorting by date, a multi-field index should be defined, with the category as the first field, and the date as the second field.  It is important to remember that the sort field must be specified in order for an index to be used. If no sort is specified, all items in a collection will be scanned (in filename order).  Not all queries can leverage an index. See the limitations for more details. 
> im the input 
> To sort collection results by a collection field, pass the `sort` argument to the `<collection>Connection` query, with the value corresponding to the desired collection field to sort by. Results are returned in ascending order.
> 
> > See [reverse pagination](/docs/graphql/queries/advanced/pagination/) for how to retrieve results in descending order.
> 
> 
> im the output  To sort collection results by a collection field, pass the sort argument to the <collectionConnection query, with the value corresponding to the desired collection field to sort by. Results are returned in ascending order.  See reverse pagination for how to retrieve results in descending order.  
> im the input Sorting on multiple fields
> 
> To sort collection results by multiple fields, we need to define a multi-field "index" in our schema. An index definition determines which fields in a collection are included in the index and the order of the fields when sorting results.
> 
> > In addition to determining the sort order of query results, indexes also impact query [performance](/docs/graphql/queries/advanced/performance/).
> 
> Here is an example index definition for our posts collection:
> 
> ```ts
> {
>   collections: [
>     {
>       label: "Blog Posts",
>       name: "post",
>       path: "content/posts",
>       format: "mdx",
>       fields: [...],
>       indexes: [{
>         name: "category-date",
>         fields: [
>           { name:"category" },
>           { name:"date" }
>         ]
>       }]
>     }
>   ]
> }
> ```
> 
> The `name` property on the index definition is used when referencing it in the `sort` argument. The `fields` property is an ordered list of the fields from the collection that should be indexed, identified by the field `name`. Results returned using the associated sort for this example would be first ordered by `category` and then by `date`.
> 
> 
> im the output Sorting on multiple fields  To sort collection results by multiple fields, we need to define a multi-field "index" in our schema. An index definition determines which fields in a collection are included in the index and the order of the fields when sorting results.  In addition to determining the sort order of query results, indexes also impact query performance.  Here is an example index definition for our posts collection:  ts {   collections: [     {       label: "Blog Posts",       name: "post",       path: "content/posts",       format: "mdx",       fields: [...],       indexes: [{         name: "category-date",         fields: [           { name:"category" },           { name:"date" }         ]       }]     }   ] }   The name property on the index definition is used when referencing it in the sort argument. The fields property is an ordered list of the fields from the collection that should be indexed, identified by the field name. Results returned using the associated sort for this example would be first ordered by category and then by date.  
> im the input Default sort order
> 
> If the `sort` parameter is not specified in a query, results will be returned based on the default filename ordering.
> 
> 
> im the output Default sort order  If the sort parameter is not specified in a query, results will be returned based on the default filename ordering.  
> im the input Examples
> 
> #
> im the output Examples  #
> im the input Sorting by a single field
> 
> Here we will query our `post` collection with `postConnection` and sort the results by the `date` field:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(sort:#&#x22;date&#x22;)#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########date
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> #
> im the output Sorting by a single field  Here we will query our post collection with postConnection and sort the results by the date field:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;date&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########date   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########}   ######]   ####}   ##}   }" / #
> im the input Sorting by multiple fields
> 
> Here we will query our `post` collection with `postConnection` and sort the results first by `category` and then by `date` using the multi-field index named `category-date`:
> 
> <GraphQLCodeBlock
>   query="{
>   ##postConnection(sort:#&#x22;category-date&#x22;)#{
>   ####edges#{
>   ######node#{
>   ########id
>   ########title
>   ########category
>   ########date
>   ######}
>   ####}
>   ##}
>   }"
>   response="{
>   ##&#x22;data&#x22;:#{
>   ####&#x22;postConnection&#x22;:#{
>   ######&#x22;edges&#x22;:#[
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,
>   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;
>   ##########}
>   ########},
>   ########{
>   ##########&#x22;node&#x22;:#{
>   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,
>   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,
>   ############&#x22;category&#x22;:#&#x22;politics&#x22;,
>   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;
>   ##########}
>   ########}
>   ######]
>   ####}
>   ##}
>   }"
> />
> 
> im the output Sorting by multiple fields  Here we will query our post collection with postConnection and sort the results first by category and then by date using the multi-field index named category-date:  <GraphQLCodeBlock   query="{   ##postConnection(sort:#&#x22;category-date&#x22;)#{   ####edges#{   ######node#{   ########id   ########title   ########category   ########date   ######}   ####}   ##}   }"   response="{   ##&#x22;data&#x22;:#{   ####&#x22;postConnection&#x22;:#{   ######&#x22;edges&#x22;:#[   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/nested/anotherPost.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Just#Another#Blog#Post&#x22;,   ############&#x22;category&#x22;:#&#x22;lifestyle&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-07-15T07:00:00.000Z&#x22;   ##########}   ########},   ########{   ##########&#x22;node&#x22;:#{   ############&#x22;id&#x22;:#&#x22;content/posts/voteForPedro.json&#x22;,   ############&#x22;title&#x22;:#&#x22;Vote#For#Pedro&#x22;,   ############&#x22;category&#x22;:#&#x22;politics&#x22;,   ############&#x22;date&#x22;:#&#x22;2022-06-15T07:00:00.000Z&#x22;   ##########}   ########}   ######]   ####}   ##}   }" /
> im the input 
