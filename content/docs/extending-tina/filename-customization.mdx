---
id: /docs/extending-tina/filename-customization
title: Filename customization
alias: Any-
last_edited: '2026-02-04T22:59:21.493Z'
next: content/docs/extending-tina/before-submit.mdx
previous: content/docs/extending-tina/format-and-parse.mdx
---

By default Tina doesn't provide any opinionated file name constraints. This is because most operating systems provide a variety of file name configurations and we didn't want users to be constrained. If you need to enforce file name constraints at the collection level, Tina provides a few options for you.

## Limitations

* Filename must contain only `a-z`, `A-Z`, `0-9` , `-`, `_`, `.`, or `/`.
* File names cannot contain spaces
* The filename generated cannot be a duplicate within the collection
* If the filename starts with `/` it will be treated as an absolute path relative to the collection root
  * Example: `/foo/bar/blog-post` will be saved as `<MyCollectionPath>/post/blog-post.md`
* If the filename does not start with `/` it will be treated as a relative to your current folder
  * Example: `bar/blog-post` will be saved as `<MyCollectionPath>/<CurrentDirectory>/bar/blog-post.md`

## Definition

| Property               | Description                                                                     |
| ---------------------- | ------------------------------------------------------------------------------- |
| `ui.filename.readonly` | Prevent the editor from editing the filename                                    |
| `ui.filename.slugify`  | A function that takes in the values of the form and returns the filename        |
| `ui.filename.parse`    | A function that parses the filename into the desired format when the user types |

## Option A: using parse

Using the parse function you can enforce file constraints within the Tina editor. The callback function you provide will be used to sanitise the user input while they're typing. 

### Example using parse to enforce snake case

```
export default defineConfig({
  //...
  schema: {
    collections: [
      {
        label: "Blog Posts",
        ui: {
          filename: {
            parse: (filename) => filename.replaceAll(" ","_"),
          }
        },
        name: "post",
        path: "content/post",
        format: "mdx",
        fields: [
          //...
        ]
      }
    ],
  },
});
```

## Option B: using slugify

The `slugify` function is useful when you want to have a file name that is *derived* from other field(s) in your collection.

<WarningCallout
  body={<>
    The `slugify` function only applies constraints when the user creates new files. Users still have complete freedom when renaming a file.
  </>}
/>

### Example with slugify and read only

```ts
export default defineConfig({
  //...
  schema: {
    collections: [
      {
        label: 'Blog Posts',
        name: 'post',
        path: 'content/post',
        format: 'md',
        ui: {
          filename: {
            // if disabled, the editor can not edit the filename
            readonly: true,
            // Example of using a custom slugify function
            slugify: (values) => {
              // Values is an object containing all the values of the form. In this case it is {title?: string, topic?: string}
              return `${values?.topic || 'no-topic'}-${values?.title
                ?.toLowerCase()
                .replace(/ /g, '-')}`
            },
          },
        },
        fields: [
          {
            type: 'string',
            label: 'Title',
            name: 'title',
          },
          {
            type: 'string',
            label: 'Topic',
            name: 'topic',
            options: ['programming', 'blacksmithing'],
          },
        ],
      },
    ],
  },
})
```

### Example with default slugify

If no slugify function is provided and there is a field with `isTitle: true`. A default slugify function will be used that strips out every non-alphanumeric character and replaces spaces with dashes.

```ts
export default defineConfig({
  //...
  schema: {
    collections: [
      {
        label: 'Blog Posts',
        name: 'post',
        path: 'content/post',
        format: 'md',
        fields: [
          {
            type: 'string',
            label: 'Title',
            name: 'title',
            // If no slugify function is provided, then by default the "title" field will be used to generate the filename
            isTitle: true,
            required: true,
          },
          {
            type: 'string',
            label: 'Topic',
            name: 'topic',
            options: ['programming', 'blacksmithing'],
          },
        ],
      },
    ],
  },
})
```
