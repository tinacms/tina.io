---
title: 'Setup Guide: Audit Content GitHub Action'
last_edited: '2025-12-09T04:46:24.465Z'
next: ''
previous: ''
---

## Overview

We've created a sample repo

This workflow fetches content paths from TinaCMS, generates feedback issues, updates lastChecked in markdown files, and opens a PR.

## Project Setup

### Preparing your content

In order to start auditing you content with AI we first need to add a field to the collection you'd like to query.

```tsx
const MyCollection : Collection = {
  label: 'My Collection'
  name: 'myCollection'
  format: 'mdx'
  fields: [
    // new field
    {
      type: 'datetime',
      name: 'lastChecked',
      ui: {
        component: 'hidden',
      }
    },
    //...
  ]

}

```

> Be sure to regenerate and commit your  `tina-lock.json` after adding the new field .

In order for the script to run we need to seed all of you existing content with a `lastChecked` field.

Navigate to the directory for the workflow

```bash
cd ./github/workflows/scripts/tina-helpers
```

Reference files:

audit-content.yml

package.json

aggregate-links.ts

tina-client.ts

.env (local/dev)

Prerequisites

Enable GitHub Actions for the organization.

1. Go to: **Your Repository  > ⚙️Settings > Models**
2. Ensure you have Models enabled for your repostory

Allow GitHub Actions to create PRs for the repository.

### Secrets

| Variable             | Source                              |
| -------------------- | ----------------------------------- |
| **TINA\_TOKEN**      | Your TinaCloud API Token            |
| **TINA\_CLIENT\_ID** | The Tina Client ID for your project |

### Variables

| Secret                             | Description                                                                                           |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **TINA\_AUDITOR\_CONTENT\_WINDOW** | A number indicating how many outdated content items will be checked when you run the action. (i.e. 5) |
| **TINA\_AUDITOR\_EXPIRY\_DAYS**    | The number of days that will pass before your content is re-evaluated after already being checked.    |
| **TINA\_AUDITOR\_SYSTEM\_PROMPT**  | The prompt that will be used to evaluate your content when passing it to GitHub model.                |
| **TINA\_AUDITOR\_QUERY**           | The query that will be used to find the content within your repo.                                     |

### Adding your Query

The query you supply as TINA\_CONTENT\_QUERY must be a connection type. For more information about connection queries please consult the [documentation](https://tina.io/docs/graphql/queries/query-documents). Note that your field only requires \_sys.path and the $first and $filter properties. The 2 filters will be supplied when the action is run and the path property will be used to locate your content.

```graphql
# Replace with your connetion
query <your-connection>($first: Float, $filter: <your-connection-filter>) {
	<your-connection>(first: $first, filter: $filter) {
		edges {
			cursor
			node {
				... on Document {
					_sys {
						path
					}
				}
			}
		}
	}
}

```

Repo must contain TinaCMS-generated client/types and content files to audit.

Node 20+ and pnpm in CI (the workflow sets these up).

Secrets and Variables

Add repo secrets:

TINA\_TOKEN: Tina Cloud API token.

TINA\_CLIENT\_ID: Tina Cloud client/workspace ID.

Add repo variable:

TINA\_AUDITOR\_QUERY: GraphQL query string used by the helper client.

Use a single-line string or a YAML multiline block in the workflow.

Example query to list items in a collection:

Files to copy into your repo

Copy workflow:

audit-content.yml

Copy helper scripts (or adapt to your structure):

package.json

tina-client.ts

aggregate-links.ts

map-links-to-content.ts

update-checked.ts

What the workflow does

run-ast-parser

Installs helper scripts and reads env from secrets/vars.

Runs aggregate-links to collect content paths using TinaClient (see aggregate-links.ts).

Exposes outputs:

items: JSON array of objects with path and content.

links: JSON array of paths.

generate-feedback

Matrix job over items (content).

Calls an AI model and creates per-file issues via actions/github-script.

update-checked

Installs helper scripts.

Runs update-checked with links to update lastChecked frontmatter.

Pretty-prints links and opens a PR with changes.

Key configuration in audit-content.yml

permissions:

contents: write, issues: write, pull-requests: write (required for commits, issues, and PRs).

Secrets/vars injection:

TINA\_TOKEN, TINA\_CLIENT\_ID via secrets.

TINA\_AUDITOR\_QUERY via repo variables (written into .env for local scripts).

pnpm usage:

Uses pnpm/action-setup\@v4 and pnpm --dir to run scripts from the helper directory.

Outputs format:

items and links are valid JSON strings emitted via $GITHUB\_OUTPUT for downstream jobs.

Local development

Use .github/scripts/tina-helpers/.env locally:

TINA\_TOKEN="..."

TINA\_CLIENT\_ID="..."

Run helper scripts:

pnpm --dir=.github/scripts/tina-helpers install

pnpm --dir=.github/scripts/tina-helpers run aggregate-links

pnpm --dir=.github/scripts/tina-helpers run map-links-to-content '\["content/path.md"]'

pnpm --dir=.github/scripts/tina-helpers run update-checked '\["content/path.md"]'

Notes and tips

pnpm --silent suppresses pnpm logs; your scripts should only print JSON to stdout when outputs are captured.

If you pass raw GraphQL between jobs, keep it as a string; only use fromJson for valid JSON.

fetch-depth: 0 is set so the PR action can commit and push.

If you need to include created issue IDs in the PR body, aggregate them via upload-artifact in the matrix job and download in update-checked before creating the PR.

Troubleshooting

“Resource not accessible by integration”: ensure the workflow runs in the base repo (not a fork), uses token: , and permissions include contents/pull-requests write.

Unexpected token “… not valid JSON”: confirm outputs used with fromJson are valid JSON; do not pass raw GraphQL there.

client undefined: regenerate Tina codegen and import the named client export from the correct path.

That’s it. After configuring secrets/vars and copying the workflow plus helper scripts, trigger the workflow via Actions → “Audit Content with AI” to generate issues, update files, and create a PR

<scrollBasedShowcase
  showcaseItems={[
    {
      title: "Tina Cloud",
      image: "",
      content:
        "The GraphQL query you run will be evaluated inside of TinaCloud. This supplies the GitHub action with the list of files it will need to locate and update.\n",
      useAsSubsection: false
    },
    {
      title: "GitHub Actions",
      image: "",
      content:
        "The GitHub actions will use the response from TinaCloud to locate the correct files within your repository.\n",
      useAsSubsection: false
    },
    {
      title: "Pull Requests",
      image: "",
      content:
        "The GitHub action will automatically create Pull Requests with hte list of files that were checked. It's important that you merge these requests before re-running the action, otherwise the content checker will evaluate them again.\n",
      useAsSubsection: true
    },
    {
      title: "Issues",
      image: "",
      content:
        "The GitHub Action will check out your repository, scan the content returned from TinaCloud, and create Issues with suggestions based on your feedback.\n",
      useAsSubsection: true
    }
  ]}
/>
