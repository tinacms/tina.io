---
id: /docs/contextual-editing/tinafield
title: The tinafield helper
last_edited: '2025-03-17T03:09:17.616Z'
next: ''
previous: ''
---

## Introduction

Tina's "click to edit" feature allows editors to select the element they want to edit on the page in order to see it in the sidebar.

<WebmEmbed embedSrc="/video/quick-edit-demo.webm" />

> [Try the demo](https://demo.tina.io/admin#/~)!

In order for this to work, Tina needs to know what document and field the
element is associated with. Tina makes this easy with the `tinaField` helper
function. Using this function, developers can add the appropriate metadata
to the `[data-tina-field]` attribute.

```jsx
import { useTina, tinaField } from 'tinacms/dist/react'

const Page = (props) => {
  const { data } = useTina(props)
  return (
    <div>
      <h1 data-tina-field={tinaField(data, 'title')}>{data.title}</h1>
    </div>
  )
}
```

Now, when you open the Tina sidebar you'll see editing overlays on any element
that's been configured.

> "Click to edit" will work for any field in your query, this means you can also click on fields from references as well.

The `tinaField` function used above is a *type-safe* helper designed to pluck the metadata out of the data object for the given
property to be used on the `[data-tina-field]` attribute:

```js
// Get metadata for the 'object' field
tinaField(data)
// Get metadata for the `data.title` field
tinaField(data, 'title')
```

## How does the `tinaField` helper work?

When not in edit-mode, the `data` returned by the `useTina` hook might look like this:

```js
{
  page: {
    title: 'Hello, world',
    blocks: [{
      __typename: 'PageBlocksHero',
      heading: 'Hi, again!',
      description: 'Some description'
      links: [{
        label: "About Us",
        url: '/about=us'
      }]
    }]
  }
}
```

Once edit-mode is enabled, Tina will update each nested object with `_tina_metadata`:

```js
{
  page: {
    title: 'Hello, world',
    blocks: [{
      __typename: 'PageBlocksHero',
      heading: 'Hi, again!',
      description: 'Some description'
      links: [{
        label: "About Us",
        url: '/about=us',
        _tina_metadata: {
          formId: "content/pages/hello-world.md",
          fields: {
            // tinaField(link, 'label') -> `023nsk-page.blocks.0.links.0.label`
            label: "page.blocks.0.links.0.label",
            url: "page.blocks.0.links.0.link",
          }
        }
      }],
      _tina_metadata: {...}
    }],
    _tina_metadata: {...}
  }
}
```

The `tinaField` helper simply plucks out the appropriate information from the `_tina_metadata` object.

## Using `tinaField` with custom React components

* Adding `[data-tina-field]` directly to a react component can be a bit tricky because React doesn't allow you to define attribute names with kebab casing. There are a couple of work arounds you can  use for adding click based editing for React components.

### Using custom attributes

The easiest way to assign `[data-tina-field]` to a React component is to create a custom attribute. This will allow you to to pass the output from the `tinaField` helper to the expecting HTML element directly as a string.

```js
import { useTina, tinaField } from 'tinacms/dist/react'
import { TinaMarkdown } from "tinacms/dist/rich-text";

const Page = (props) => {
  const { data } = useTina(props);
  return (
    <Section tinaField={tinaField(data.page, 'body')}>
      <TinaMarkdown content={data.page.body} />
    </Section>
  );
};

type SectionProps = {
  children?: React.ReactNode;
  tinaField?: string;
};

const Section = ({ children, tinaField }: SectionProps) => {
  return <section data-tina-field={tinaField}>{children}</section>;
};
```

### Passing the outer object for the field

A less ideal solution would be to pass the outer object housing the field we want directly into our component. This allows us to cherry pick the field and use it for our `[data-tina-field]` attribute. While this approach works well for fields with multiple layers of nesting, it can make it difficult to figure out which elements in our code we can edit contextually from from a glance.

```js
import { useTina, tinaField } from 'tinacms/dist/react'
import { TinaMarkdown } from "tinacms/dist/rich-text";

const Page = (props) => {
  const { data } = useTina(props);
  return (
    <Section data={data.page}>
      <TinaMarkdown content={data.page.body} />
    </Section>
  );
};

type SectionProps = {
  data: any;
  children?: React.ReactNode;
};

const Section = ({ data, children }: SectionProps) => {
  return (
    <section data-tina-field={tinaField(data, 'body')}>{children}</section>
  );
};
```

### Using forwardRef

This approach is a little tricker to get right in a type safe manner. By using a `forwardRef` we can apply the `[data-tina-field]` attribute to the React component being edited. The attribute gets passed to the corresponding HTML element when we use the spread operator on `props`.

```
const Page = (props) => {
  const { data } = useTina(props);
  return (
    <Section data-tina-field={tinaField(data, 'body')}>
      <TinaMarkdown content={data.body} />
    </Section>
  );
};

type SectionProps = {
  children?: React.ReactNode;
};

const Section = forwardRef<HTMLEmbedElement, SectionProps>(
  ({ children, ...props }, ref) => {
    return (
      <section ref={ref} {...props}>
        {children}
      </section>
    );
  }
);
Section.displayName = 'Section';

```

## Important notes

* The `tinaField` helper does not affect the flow of data from Tina. It simply determines which part of the form Tina will open when the user clicks the HTML element it was supplied to.
* `[data-tina-field]` cannot be applied directly to the [TinaMarkdown](https://tina.io/docs/editing/markdown#rendering-content-with-tinamarkdown) component. This is because the TinaMarkdown component doesn't render a root element in the DOM, meaning there's no component to attach the editing window to.

## API Reference

| Argument   | Description                                                                                                | Type   | Required |
| ---------- | ---------------------------------------------------------------------------------------------------------- | ------ | -------- |
| `object`   | The object which holds the field you're accessing                                                          | Object | Yes      |
| `property` | The property from the object which you're accessing, omitting this will return the object field's metadata | String | No       |

```jsx
// components/blocks/hero
import { tinaField } from 'tinacms/dist/react'

export const HeroComponent = (props) => {
  return (
    <div>
      <h4 data-tina-field={tinaField(props, 'heading')}>{props.heading}</h4>
      <p data-tina-field={tinaField(props, 'message')}>{props.message}</p>
      <ul data-tina-field={tinaField(props, 'links')}>
        {props.links.map((link) => (
          <li>
            <a data-tina-field={tinaField(link)} href={link.url}>
              {link.label}
            </a>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

Notice that the `<a>` tag's data attribute only needs access to the `link` data object.

## Styling the visual editing interface

When Tina finds an element with the `[data-tina-field]` attribute, it will attach some CSS to it when in edit mode, clicking on the element triggers
the Tina form to open and focus the matching field.

Since Tina uses CSS to achieve the interface, it's possible for styles to collide. Overriding and customizing Tina's
styles are encouraged. Here's an example of overriding the outline color to red:

```css
.__tina-quick-editing-enabled [data-tina-field] {
  outline: 2px dashed rgba(254, 34, 56, 0.5);
}
.__tina-quick-editing-enabled [data-tina-field]:hover {
  outline: 2px dashed rgba(254, 34, 56, 1);
}
```
